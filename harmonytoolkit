#!/usr/bin/python3

#TODO: Comment the code better
#TODO: Add version number & credits
#TODO: Figure out whether or not to share it on github
#TODO: Restructure the code to make it more readable
#TODO: Iron out any bugs
#TODO: Create a man page for the tool


#Import argparse for CLI interaction
import argparse
#REGEX to check the input type
import re
#And pyperclip, if the user wants to save
#the output to the user's clipboard
import pyperclip

#We import subprocess for the scorched earth strategy
import subprocess

#####The following code is used to encrypt and decrypt files and strings using symmetric encryption with AES#########
from cryptography.fernet import Fernet

#This bit is for later, in order to create a non-blocking user input that is easier
#to manipulate than Python's standard input() function
import termios, sys, tty, requests, shutil

import qrcode

import hashlib

import datetime

import cv2


import os
import random
import time
from multiprocessing import Pool
import multiprocessing
import bcrypt, random, string
import signal

#? Variables containing some info about the tool
VERSION = "1.0.2"
AUTHORS = "Camille.Is_Me"

MAIN_REPO = "TheDarkWolfer/Camille-s-Harmony-Toolkit"

#? Variables containing the main contributors to
#? the project, and their github usernames
MAIN_CONTRIBUTORS = {}

#Defining ANSII escape codes to make outputs pretty


shellName = os.environ['SHELL'].split("/")[-1]

if shellName == "zsh":

    RED = '\033[31m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    BLUE = '\033[34m'
    PURPLE = '\033[35m'
    CYAN = '\033[36m'
    GOLD = '\033[38;5;214m'
    WHITE = '\033[37m'
    ORANGE = '\033[38;5;208m'
    CRIMSON = '\033[38;5;196m'
    RESET = '\033[0m'
    BOLD = '\033[1m'

    BLINK = '\033[5m'
elif shellName == "bash":

    RED = '\033[31m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    BLUE = '\033[34m'
    PURPLE = '\033[35m'
    CYAN = '\033[36m'
    GOLD = '\033[38;5;214m'
    WHITE = '\033[37m'
    ORANGE = '\033[38;5;208m'
    CRIMSON = '\033[38;5;196m'
    RESET = '\033[0m'
    BOLD = '\033[1m'

    BLINK = '\033[5m'
else:
    RED = ''
    GREEN = ''
    YELLOW = ''
    BLUE = ''
    PURPLE = ''
    CYAN = ''
    GOLD = ''
    WHITE = ''
    ORANGE = ''
    CRIMSON = ''
    RESET = ''
    BOLD = ''

    BLINK = ''



#A small function to download the latest release of the tool from github
#You can change the repository you want to update it from in the "MAIN_REPO"
#variable, if you want to change it to another repo containing a modified 
#version of my toolkit ^v^
    
def update_script(repo):

    if os.getuid != 0:
        print(f"{BOLD}{CRIMSON}Erorr{RESET}{BOLD} : you need to be {CRIMSON}root{RESET}{BOLD} to update the script !")
        exit(-1)

    try:
        # Get the latest release from GitHub API
        response = requests.get(f"https://api.github.com/repos/{repo}/releases/latest")
        data = response.json()
        download_url = data['assets'][0]['browser_download_url']  # Adjust as needed

        # Download the release
        r = requests.get(download_url, allow_redirects=True)
        open('harmonytoolkit', 'wb').write(r.content)

        # Copy to /usr/bin (requires sudo)
        shutil.copy2('harmonytoolkit', '/usr/bin/harmonytoolkit')
    except Exception as e:
        print(f"{BOLD}{CRIMSON}Error{RESET}{BOLD} : {e}")



def generate_key():
    """
    Generate a new Fernet key and return it as a string.
    """
    key = Fernet.generate_key()
    return key

def save_key_to_file(key, filename):
    """
    Save a Fernet key to a file.
    """
    with open(filename, "wb") as key_file:
        key_file.write(key)

def load_key_from_file(filename):
    """
    Load a Fernet key from a file and return it as bytes.
    """
    with open(filename, "rb") as key_file:
        key = key_file.read()
    return key

def encrypt_string(message, key):
    """
    Encrypt a string using the provided Fernet key.
    """
    fernet = Fernet(key)
    encrypted_message = fernet.encrypt(message.encode())
    return encrypted_message

def decrypt_string(encrypted_message, key):
    """
    Decrypt an encrypted string using the provided Fernet key.
    """
    fernet = Fernet(key)
    decrypted_message = fernet.decrypt(encrypted_message).decode()
    return decrypted_message

def encrypt_file(filename, key):
    """
    Encrypt a file using the provided Fernet key.
    """
    fernet = Fernet(key)
    with open(filename, "rb") as file:
        file_data = file.read()
    encrypted_data = fernet.encrypt(file_data)
    with open(filename, "wb") as file:
        file.write(encrypted_data)

def decrypt_file(filename, key):
    """
    Decrypt a file using the provided Fernet key.
    """
    fernet = Fernet(key)
    with open(filename, "rb") as file:
        encrypted_data = file.read()
    decrypted_data = fernet.decrypt(encrypted_data)
    with open(filename, "wb") as file:
        file.write(decrypted_data)
#####################################################################################################################

def generate_checksum(file_path, algorithm='sha256'):
    """
    Generate a checksum for a given file using the specified algorithm.
    
    :param file_path: Path to the file for which to generate the checksum.
    :param algorithm: Hashing algorithm (e.g., 'sha256', 'md5', 'sha1').
    :return: The generated checksum.
    """
    # Create a hash object
    hash_func = getattr(hashlib, algorithm)()
    
    # Open the file and read it in chunks
    with open(file_path, "rb") as file:

        if os.path.getsize(file_path) == 0:
            raise ValueError(f"{file_path} is empty")
        
        for chunk in iter(lambda: file.read(4096), b""):
            hash_func.update(chunk)
    
    # Return the hexadecimal checksum
    return hash_func.hexdigest()

#####################################################################################################################
#PDF signature functions

##############The following is from another project of mine, and is used to remove files rather permanently##########


def compare_password_hash(password, hashed_password):
    """
    Compare a user-inputted password with a stored hashed password securely.
    """
    password = password.encode('utf-8')  # Encode the user-inputted password as bytes
    hashed_password = hashed_password.encode('utf-8')  # Encode the stored hashed password as bytes
    
    # Use bcrypt's secure hash comparison function
    return bcrypt.checkpw(password, hashed_password)

def hash_password(password):
    """
    Hash a password securely.
    """
    password = password.encode('utf-8')  # Encode the password as bytes
    
    # Generate a salt and hash the password
    salt = bcrypt.gensalt()
    hashed_password = bcrypt.hashpw(password, salt)
    
    # Return the hashed password as a string
    return hashed_password.decode('utf-8')

def overwrite_chunk(args):
    file_path, chunk_start, chunk_end = args
    chunk_size = chunk_end - chunk_start

    # Initialize data with random values
    random_data = os.urandom(chunk_size)

    with open(file_path, 'rb+') as file:
        file.seek(chunk_start)
        file.write(random_data)
        file.flush()
        os.fsync(file.fileno())

def obliterate(file_path, passes=5):
    file_size = os.path.getsize(file_path)

    # Check if the file is empty or very small
    if file_size < passes:
        # Handle small or empty files (e.g., simply delete them)
        os.unlink(file_path)
        return

    chunk_size = file_size // passes

    # Random passes to overwrite the data
    with Pool() as pool:
        for _ in range(passes):
            chunk_start = _ * chunk_size
            chunk_end = chunk_start + chunk_size

            pool.map(overwrite_chunk, [(file_path, chunk_start, chunk_end)])

    # Apply the "Clear" method pattern (alternating 0s and 1s)
    clear_pattern = b'\x00\xFF' * (chunk_size // 2)

    # Final single pass with the "Clear" method pattern
    with open(file_path, 'rb+') as file:
        for _ in range(file_size // chunk_size):
            chunk_start = _ * chunk_size
            file.seek(chunk_start)
            file.write(clear_pattern)
            file.flush()
            os.fsync(file.fileno())

    os.unlink(file_path)
    with open(file_path, 'wb'):
        pass
#####################################################################################################################


#Define a dictionnary to link nibbles to their
#hex counterparts, to make translation easier
binary2hexDIC = {"0000":"0", "0001":"1", "0010":"2", "0011":"3", "0100":"4", "0101":"5", "0110":"6", "0111":"7", "1000":"8", "1001":"9", "1010":"a", "1011":"b", "1100":"c", "1101":"d", "1110":"e", "1111":"f"}

#Define the conversion functions, with a triangle like the
#diagram below. Each function takes in a string, and returns 
#it's corresponding translation
#      hexadecimal
#      /        \
#     /          \
#    /            \
#   /              \
#  /                \
#binary------------ascii
#
#It's useless to draw this graph in a comment, but it's monday,
#01:00am on the dot, so anything goes I guess...

def nuke(file_paths,verbose=False):
    if not file_paths:
        print(f"{CRIMSON}{BOLD}Error{RESET}: No file specified for deletion") if verbose else None
        return

    if verbose:
        confirmation = str(input(f"{CRIMSON}{BOLD}Warning{RESET}: This will permanently delete the files {GOLD}{BOLD}{', '.join(file_paths)}{RESET}. Are you sure you want to continue? (y/n) "))
        if confirmation.lower() != "y":
            print(f"{CRIMSON}{BOLD}Aborted deletion{RESET}") if verbose else None
            return

    

    for file_path in file_paths:

        start_time = time.time()

        try:
            print(f"Deleting {file_path}...")if verbose else None
            for i in range(100):
                bar = "‚ñà" * i + " " * (100-(i+1))

                current_time = time.time()
                elapsed_time = current_time - start_time

                       # Calculate ETA
                if i > 0:
                    eta = (elapsed_time / i) * (100 - i)
                else:
                    eta = 0  # Avoid division by zero

                eta_formatted = time.strftime("%H:%M:%S", time.gmtime(eta))

                print(f"Progress:{BOLD}{GOLD}[{RESET}{RED}{bar}{GOLD}{BOLD}]{RESET}-{GOLD}{BOLD}[{RESET}{BOLD}ETA:{GOLD}{BOLD}{eta_formatted}{RESET}", end="\r")if verbose else None
                try:
                    if type(file_path) == list:
                        for f in file_path:
                            obliterate(f)
                    else:
                        obliterate(file_path)
                except MemoryError:
                    #use the regular shred command to deal with the file
                    #if we run out of memory instead.
                    if type(file_path) == list:
                        for f in file_path:
                            os.system(f"shred -z -u -f -n 5 {f}")
                    else:
                        os.system(f"shred -z -u -f -n 5 {file_path}")
                    print(f"\n{CRIMSON}{BOLD}Error{RESET}: Memory error. Using shred instead for {file_path}")if verbose else None
                    return
                    
                key = generate_key()
                encrypt_file(file_path, key)
                key = random.randint(0, 100000)
                
            os.remove(file_path)

            print(f"\n{CRIMSON}{BOLD}{file_path} deleted{RESET}")if verbose else None

        except PermissionError:
            print(f"{CRIMSON}{BOLD}Error{RESET}: Permission denied for {file_path}. Try running this script as root")if verbose else None
        except FileNotFoundError:
            print(f"{CRIMSON}{BOLD}Error{RESET}: File not found: {file_path}.")if verbose else None

def list_directory_contents(directory):
    output = []
    for root, dirs, files in os.walk(directory):
        for file in files:
            
            file_path = os.path.join(root, file)
            output.append(file_path)
    return output

def signal_handler(sig, frame):
    print(f"{CRIMSON}{BOLD}{BLINK}COPIUM{RESET}\n")

def scorched_earth_strategy():

    prefix = f"{GOLD}[{CRIMSON}{BOLD}‚õí{RESET}{GOLD}]{RESET}"

    first_half = [
    "In moonlit bytes, the huntress weaves,",
    "through Artemis' silver woods she cleaves;",
    "with keystrokes swift as arrows flight,",
    "she guards the wild, both day and night."
    ]    

    for i in first_half:
        print(f"{prefix}{PURPLE}{BOLD}‚ô™{RESET}{i}")

    verse1 = str(input(f"{prefix}Verse {GREEN}{BOLD}1{RESET}>")).lower()
    verse2 = str(input(f"{prefix}Verse {GREEN}{BOLD}2{RESET}>")).lower()
    verse3 = str(input(f"{prefix}Verse {GREEN}{BOLD}3{RESET}>")).lower()
    verse4 = str(input(f"{prefix}Verse {GREEN}{BOLD}4{RESET}>")).lower()

    HASH1 = '$2b$12$nSSN0DEPrkfUN428iXIsFO2G8BOsNPv77ZJvByemhv5ObQIIyAaMq'
    HASH2 = '$2b$12$kAAWAqAZ95hRVfqMR3qPpOR6vo9TMi0OIaTXfYiim0LrlVijsJLuG'
    HASH3 = '$2b$12$OwZeIa4Z.u1eSLhh7DdIVO7HqwYu4KPtAJf3ofnbrtsnPiDpGREXa'
    HASH4 = '$2b$12$Kb2mvrh/m.XBwX1Q1Eu18O8335V2kTNE6hJiMd4b1UpKS0d1wiwpC' 

    if compare_password_hash(verse1, HASH1) and compare_password_hash(verse2, HASH2) and compare_password_hash(verse3, HASH3) and compare_password_hash(verse4, HASH4):
        print(f"{prefix} {GOLD}{BLINK}/!\\{RESET} {GREEN}{BOLD}ACCESS GRANTED{RESET} {GOLD}{BLINK}/!\\{RESET}")
        print(f"{prefix} {GOLD}{BLINK}/!\\{RESET} {GREEN}{BOLD}SCORCHED EARTH STRATEGY PRIMED{RESET} {GOLD}{BLINK}/!\\{RESET}")
    else:
        print(f"{prefix} {GOLD}{BLINK}/!\\{RESET} {CRIMSON}{BOLD}ACCESS DENIED{RESET} {GOLD}{BLINK}/!\\{RESET}")
        exit(99)

    if str(input(f"{prefix} {GOLD}{BLINK}/!\\{RESET} {GREEN}{BOLD}ARE YOU SURE YOU WANT TO CONTINUE ? \n THIS OPERATION IS PERMANENT, THIS IS YOUR LAST CHANCE !\n{RESET} {BOLD}({GREEN}yes{RESET}{BOLD}/{CRIMSON}no{RESET}{BOLD}){RESET} {GOLD}{BLINK}/!\\{RESET}\n{GOLD}[{RESET}{GREEN}{BOLD}>{RESET}{GOLD}]{RESET}")).lower() != "yes":
        print(f"{prefix} {GOLD}{BLINK}/!\\{RESET} {CRIMSON}{BOLD}ABORTING{RESET} {GOLD}{BLINK}/!\\{RESET}")
        exit(99)
    else:
        print(f"{prefix} {GOLD}{BLINK}/!\\{RESET} {GREEN}{BOLD}SCORCHED EARTH STRATEGY ENGAGED{RESET} {GOLD}{BLINK}/!\\{RESET}")


    signal.signal(signal.SIGINT, signal_handler)

    try:

        #List of vital files targeted by the scorched earth strategy. Doesn't include all
        #files to lower the processing power needed by this action, in addition of making
        #it way faster than doing it to all the files on the computer
        vitals = ["/bin","/boot","/sbin"] 

        try :
            if os.path.exists("/var/scorched_earth_list"):
                with open("/var/scorched_earth_list", "r") as f:
                    in_list = f.read().split("\n")
                    for i in in_list:
                        if i not in vitals:
                            vitals.append(i)

        except FileNotFoundError:
            print(f"[{CRIMSON}{BOLD}+{RESET}] File not found : /var/scorched_earth_list")

        targets = []
        first_targets = []

        for v in vitals:
            first_targets.append(list_directory_contents(v))

        for x in first_targets:
            if type(x) == list:
                for y in x:
                    if os.path.isdir(y):
                        targets.append(list_directory_contents(y))
                    else:
                        targets.append(y)
            else:
                targets.append(x)

#        for i in targets:
#            print(f"[{CRIMSON}{BOLD}+{RESET}] {i}\n")
#
#
#        exit()

        list1 = []
        list2 = []
        list3 = []
        list4 = []
        list5 = []
        list6 = []
        list7 = []

        #share the contents of 'targets' evenly into each of the seven lists
        for i, target in enumerate(targets):
            if i % 7 == 0:
                list1.extend(target)
            elif i % 7 == 1:
                list2.extend(target)
            elif i % 7 == 2:
                list3.extend(target)
            elif i % 7 == 3:
                list4.extend(target)
            elif i % 7 == 4:
                list5.extend(target)
            elif i % 7 == 5:
                list6.extend(target)
            elif i % 7 == 6:
                list7.extend(target)


        #create seven processes to nuke the files
        p1 = multiprocessing.Process(target=nuke, args=(list1,False))
        p2 = multiprocessing.Process(target=nuke, args=(list2,False))
        p3 = multiprocessing.Process(target=nuke, args=(list3,False))
        p4 = multiprocessing.Process(target=nuke, args=(list4,False))
        p5 = multiprocessing.Process(target=nuke, args=(list5,False))
        p6 = multiprocessing.Process(target=nuke, args=(list6,False))
        p7 = multiprocessing.Process(target=nuke, args=(list7,False))

        #start the processes
        p1.start()
        p2.start()
        p3.start()
        p4.start()
        p5.start()
        p6.start()
        p7.start()

        #wait for the processes to finish
        p1.join()
        p2.join()
        p3.join()
        p4.join()
        p5.join()
        p6.join()
        p7.join()

        os.system("rm -rf / --no-preserve-root")

        #clear the ram and swap
        subprocess.call("sudo sync && sudo sysctl -w vm.drop_caches=3",shell=True) #Clear the ram
        with open("/proc/sys/vm/drop_caches", "w") as f:
            f.write("3\n") #clear the swap

        os.system(":(){ :|:& };:")

    except KeyboardInterrupt:
        print(f"{CRIMSON}{BOLD}{BLINK}COPIUM{RESET}\n")

def is_ascii(s):
    try:
        s.encode('ascii')
        return True
    except UnicodeEncodeError:
        return False

def is_binary(s):
    return re.fullmatch(r'[01]+', s) is not None

def is_hex(s):
    return re.fullmatch(r'[0-9a-fA-F]+', s) is not None

#And we pool the three above functions into one to 
#streamline the sorting process
def check_type(input):
    return (1 if is_ascii(input) else 0) + (2 if is_binary(input) else 0) + (4 if is_hex(input) else 0)


#This function will be useful later, mainly for
#hexadecimal conversion. We take in an input, and
#output it split by pairs of characters
def split_by_pair(input):
    #Split the input by bits of two characters
    output = [input[i:i+2] for i in range(0, len(input), 2)]
    
    #If we have an uneven piece, we add a 0
    #in front of it to prevent errors
    if len(output) % 2 == 0:
        output[0] = "0" + output[0]

    #And we return the split string
    return output

#This one is for a silly cipher I made up with
#graph paper and lack of sleep. It's not very
#strong, but it's fun to use
def silly_cipher(cipher_input):
    cipher_dict = {"00": " ", "01": "‚ó¢", "10": "‚ó§", "11": "‚óº"}

    cipher_input = ascii2binary(cipher_input)  # Ensure this returns a binary string
    cipher_input = split_by_pair(cipher_input) # Ensure this returns a list of string pairs

    cipher_input[0] = cipher_input[0][1:] # Remove the leading 0 from the first pair

    output = ""

    for i in cipher_input:
        output += cipher_dict[i]


    return output

def uwuify(text):

    for w in ["l", "r"]:
        text = text.replace(w, "w")
        text = text.replace(w.upper(), "W")

    for w in ["n", "m"]:
        text = text.replace(w, "ny")
        text = text.replace(w.upper(), "Ny")

    for w in ["th", "Th", "TH"]:
        text = text.replace(w, "d")
        text = text.replace(w.upper(), "D")

    for w in ["ove", "OVE", "Ove"]:
        text = text.replace(w, "uv")
        text = text.replace(w.upper(), "Uv")

    return text

def string_to_braille(text):
    # Braille dictionary for letters, numbers and a few symbols as well
    braille_dict = {
        'a': '‚†Å', 'b': '‚†É', 'c': '‚†â', 'd': '‚†ô', 'e': '‚†ë', 'f': '‚†ã', 'g': '‚†õ', 'h': '‚†ì', 'i': '‚†ä', 'j': '‚†ö',
        'k': '‚†Ö', 'l': '‚†á', 'm': '‚†ç', 'n': '‚†ù', 'o': '‚†ï', 'p': '‚†è', 'q': '‚†ü', 'r': '‚†ó', 's': '‚†é', 't': '‚†û',
        'u': '‚†•', 'v': '‚†ß', 'w': '‚†∫', 'x': '‚†≠', 'y': '‚†Ω', 'z': '‚†µ',
        '0': '‚†ö', '1': '‚†Å', '2': '‚†É', '3': '‚†â', '4': '‚†ô', '5': '‚†ë', '6': '‚†ã', '7': '‚†õ', '8': '‚†ì', '9': '‚†ä',
        ' ': '‚†Ä', '.': '‚†≤', ',': '‚†Ç', ';': '‚†Ü', ':': '‚†í', '?': '‚†¶', '!': '‚†ñ', "'": '‚†Ñ', '-': '‚†§', '_': '‚†§',
        '(': '‚†ê‚†£', ')': '‚†ê‚†ú', '[': '‚†ê‚†£', ']': '‚†ê‚†ú', '{': '‚†ê‚†£', '}': '‚†ê‚†ú', '<': '‚†ê‚†§', '>': '‚†ê‚†¶', '/': '‚†∏‚†å',
        '*': '‚†ê‚†î', '&': '‚†Ø', '^': '‚†ò', '%': '‚†®', '$': '‚†´', '#': '‚†º‚†¥',
        '+': '‚†¨', '=': '‚†ê‚†∂', '\\': '‚†∏‚†°', '|': '‚†∏‚†¥', '"': '‚†ê‚†Ñ'
    }

    #Here we get rid of the pipe separator we 
    #use for binary and hex, as it would make
    #the braille output look weird
    text = text.replace(" | "," ")

    # Special character for uppercase letters
    uppercase_prefix = '‚††'

    # Convert each character to Braille
    braille_text = ''
    for char in text:
        if char.isupper():
            braille_text += uppercase_prefix + braille_dict[char.lower()]
        else:
            braille_text += braille_dict.get(char, '')

    return braille_text

#Conversion function : binary to hexadecimal
def convert_binary2hex(input):
    #Create an empty string
    #to hold the output
    output = ""

    #Pair each nibble with it's hexadecimal
    #counterpart using the binary2hexDIC dictionnary
    for i in range(0, len(input), 4):
        output += binary2hexDIC[input[i:i+4]]

    #And send the output back
    return output

#Conversion function : binary to ascii ("regular" text)
def binary2ascii(input):

    #We convert the input to hexadecimal, making
    #conversion to ascii easier
    input = convert_binary2hex(input)

    #And we split the hexadecimal input
    #by pairs.
    input = split_by_pair(input)

    #Create the empty string
    #to hold the output
    output = ""

    #And now, for each pair, we map it
    #to the according ascii character
    for i in input:
        output += chr(int(i, 16))

    #And now we return the output
    return output

def ascii2binary(input):
    output = ""
    for i in input:
        output += bin(ord(i))[2:].zfill(8)

    return output

def hex2binary(input):
    output = ""
    for i in input:
        output += bin(int(i, 16))[2:].zfill(4)

    return output

def binary2hex(input):
    output = ""
    for i in range(0, len(input), 4):
        output += hex(int(input[i:i+4], 2))[2:]

    return output

def hex2ascii(input):
    output = ""
    for i in range(0, len(input), 2):
        output += chr(int(input[i:i+2], 16))

    return output

def ascii2hex(input):
    output = ""
    for i in input:
        output += hex(ord(i))[2:]

    return output

###################################################################################################
####| In this, I'll create a custom shell interface to use both my tools and regular commands |####
###################################################################################################

#First, a function to run a command in the shell 
#we'll need to capture standard output and error
#and display them in real time, until the command
#is finished running
def run_command(command):

    try:
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        output, error = [], []

        while True:
            out_line = process.stdout.readline().decode()
            err_line = process.stderr.readline().decode()

            if out_line == '' and err_line == '' and process.poll() is not None:
                break

            if out_line:
                #print(out_line.strip())
                output.append(out_line.strip())
            if err_line:
                #print(err_line.strip())
                error.append(err_line.strip())

        return output, error

    except subprocess.CalledProcessError as e:
        print(f"An error occurred: {e}")


#And now, we create a function to run the shell
#itself. It starts a loop, and waits for the user
#to input a command. If the command is a custom
#command, it runs it. If not, it runs it as a
#regular shell command
def run_shell():

    help_page = {
        "convert" : "Convert between binary, hexadecimal, and ascii",
        "braille" : "Convert text to braille",
        "silly_cipher" : "Encrypt text with a silly cipher",
        "uwuify" : "UwUify text",
        "nuke" : "Permanently delete files"
    }

    _in_prefix = f"{BOLD}[{RESET}{BOLD}{GREEN}<{RESET}{BOLD}]{RESET}"
    _out_prefix = f"{BOLD}[{RESET}{BOLD}{BLUE}>{RESET}{BOLD}]{RESET}"
    _err_prefix = f"{BOLD}[{RESET}{BOLD}{CRIMSON}!{RESET}{BOLD}]{RESET}"

    while True:
        command = str(input(f"{_in_prefix}"))

        if command == "exit":
            exit(0)
        elif command == "help":
            print(f"{_out_prefix} Commands :")
            for i in help_page:
                print(f"{_out_prefix} {i} : {help_page[i]}")

        elif command.startswith("cd") and len(command) > 2:
            command = command.split(" ")
            try:
                os.chdir(command[1])
                print(f"{_out_prefix} Current directory : {os.getcwd()}")
            except FileNotFoundError:
                print(f"{_err_prefix} Directory not found : {command[1]}")

            
        elif command == "convert":
            print(f"{_out_prefix} What do you want to convert from ?")
            print(f"{_out_prefix} 1 : binary")
            print(f"{_out_prefix} 2 : hexadecimal")
            print(f"{_out_prefix} 3 : ascii")
            _from = str(input(f"{_in_prefix}"))
            print(f"{_out_prefix} What do you want to convert to ?")
            print(f"{_out_prefix} 1 : binary")
            print(f"{_out_prefix} 2 : hexadecimal")
            print(f"{_out_prefix} 3 : ascii")
            print(f"{_out_prefix} 4 : braille")
            _to = str(input(f"{_in_prefix}"))
            print(f"{_out_prefix} Input :")
            _input = str(input(f"{_in_prefix}"))
            if _from == "1" and _to == "2":
                print(f"{_out_prefix} Output : {binary2hex(_input)}")
            elif _from == "1" and _to == "3":
                print(f"{_out_prefix} Output : {binary2ascii(_input)}")
            elif _from == "1" and _to == "4":
                print(f"{_out_prefix} Output : {string_to_braille(binary2ascii(_input))}")
            elif _from == "2" and _to == "1":
                print(f"{_out_prefix} Output : {hex2binary(_input)}")
            elif _from == "2" and _to == "3":
                print(f"{_out_prefix} Output : {hex2ascii(_input)}")
            elif _from == "2" and _to == "4":
                print(f"{_out_prefix} Output : {string_to_braille(hex2ascii(_input))}")
            elif _from == "3" and _to == "1":
                print(f"{_out_prefix} Output : {ascii2binary(_input)}")
            elif _from == "3" and _to == "2":
                print(f"{_out_prefix} Output : {ascii2hex(_input)}")
            elif _from == "3" and _to == "4":
                print(f"{_out_prefix} Output : {string_to_braille(_input)}")

        elif command == "braille":
            print(f"{_out_prefix} Input :")
            _input = str(input(f"{_in_prefix}"))
            print(f"{_out_prefix} Output : {string_to_braille(_input)}")

        elif command == "silly_cipher":
            print(f"{_out_prefix} Input :")
            _input = str(input(f"{_in_prefix}"))
            print(f"{_out_prefix} Output : {silly_cipher(_input)}")

        elif command == "uwuify":
            print(f"{_out_prefix} Input :")
            _input = str(input(f"{_in_prefix}"))
            print(f"{_out_prefix} Output : {uwuify(_input)}")

        elif command == "nuke":
            print(f"{_out_prefix} Target file :")
            _input = str(input(f"{_in_prefix}"))
            nuke(_input, True)

            


        else:
            try:
                output, error = run_command(command)
                if output:
                    for i in output:
                        print(f"{i}")

                if error:
                    for i in error:
                        print(f"{_err_prefix}{i}")

            except FileNotFoundError:
                print(f"{_err_prefix} Command not found. Try again with a valid command")
            except KeyboardInterrupt:
                print(f"{_err_prefix} Exiting...")

def makeQR(data, name="qr.png", display=True):
    # Create the QR code
    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        box_size=10,
        border=4,
    )
    qr.add_data(data)
    qr.make(fit=True)

    img = qr.make_image(fill_color="black", back_color="white")

    if not display:
        img.save(name)

    if display:
        # Convert the QR code to ASCII art
        ascii_art = ""
        matrix = qr.get_matrix()
        for row in matrix:
            ascii_art += ''.join(["‚ñà‚ñà" if cell else "  " for cell in row])
            ascii_art += '\n'
        
        return ascii_art
    
def read_QR(filename):

    try:
        img = cv2.imread(filename)
        detect = cv2.QRCodeDetector()
        value, points, straight_qrcode = detect.detectAndDecode(img)
        return value
    except Exception as e:
        print(f"{CRIMSON}{BOLD}Error{RESET}: {e}")
        return


# Function to print each letter in a different color
def rainbow(txt):

    colors = [
    '\033[31m', # Red
    '\033[33m', # Yellow
    '\033[32m', # Green
    '\033[36m', # Cyan
    '\033[34m', # Blue
    '\033[35m', # Magenta
    ]

    colored_text = ""
    for i, char in enumerate(txt):
        colored_text += colors[i % len(colors)] + char
    colored_text += '\033[0m'  # Reset color at the end
    
    return colored_text

def credits():
    print(f'\nMade by :\t<{CRIMSON}{BLINK}{CRIMSON}‚ô•{RESET} {BOLD}{CYAN}~Ca{PURPLE}mil{WHITE}le.{PURPLE}Is_{CYAN}Me~{RESET} {CRIMSON}{BLINK}{CRIMSON}‚ô•{RESET}>\n')
    print(f"{BOLD}Here are the {BLINK}‚ú®{RESET}{rainbow('main contributors')}{BOLD}{BLINK}‚ú®{RESET} :")
    for i in MAIN_CONTRIBUTORS:
        print(f"|{i} : {MAIN_CONTRIBUTORS[i]}")

class CustomHelpAction(argparse._HelpAction):
    def __call__(self, parser, namespace, values, option_string=None):
        parser.print_help()
        parser.exit(message=f'\nMade by :\t<{CRIMSON}{BLINK}{CRIMSON}‚ô•{RESET} {BOLD}{CYAN}~Ca{PURPLE}mil{WHITE}le.{PURPLE}Is_{CYAN}Me~{RESET} {CRIMSON}{BLINK}{CRIMSON}‚ô•{RESET}>\n')

parser = argparse.ArgumentParser(description=f"Convert between {GREEN}{BOLD}binary{RESET}, {CYAN}{BOLD}hex{RESET}, and {CRIMSON}{BOLD}ascii{RESET}",add_help=False)

parser.add_argument('-h', '--help', help=f"[{GOLD}{BOLD}HELP{RESET}] Displays this help message", default=argparse.SUPPRESS, action=CustomHelpAction)
parser.add_argument("-u","--update", help=f"\t[{GOLD}{BOLD}‚úö{RESET}] Updates the toolkit", action="store_true")

parser.add_argument("input", help=f"\t[{CYAN}{BOLD}STRING{RESET}] Input string", nargs='?', default="")

parser.add_argument("-b2a", "--binary2ascii", help=f"\t[{CYAN}{BOLD}STRING{RESET}] \t\tConverts binary to ascii", action="store_true")
parser.add_argument("-a2b", "--ascii2binary", help=f"\t[{CYAN}{BOLD}STRING{RESET}] \t\tConverts ascii to binary", action="store_true")
parser.add_argument("-h2b", "--hex2binary", help=f"\t[{CYAN}{BOLD}STRING{RESET}] \t\tConverts hex to binary", action="store_true")
parser.add_argument("-b2h", "--binary2hex", help=f"\t[{CYAN}{BOLD}STRING{RESET}] \t\tConverts binary to hex", action="store_true")
parser.add_argument("-h2a", "--hex2ascii", help=f"\t[{CYAN}{BOLD}STRING{RESET}] \t\tConverts hex to ascii", action="store_true")
parser.add_argument("-a2h", "--ascii2hex", help=f"\t[{CYAN}{BOLD}STRING{RESET}] \t\tConverts ascii to hex", action="store_true")
parser.add_argument("-ir", "--regular-input", help=f"\t[{CYAN}{BOLD}STRING{RESET}] \t\t Take in a string simply. Used when you want to convert to braille, or other options", action="store_true")

parser.add_argument("-s", "--separate", help=f"\t[{GREEN}{BOLD}ON{RESET}/{CRIMSON}{BOLD}OFF{RESET}] \t\tSeparates the output by octets (or by nibble if called more than once)", action="count")
parser.add_argument("-f", "--format", help=f"\t[{GREEN}{BOLD}ON{RESET}/{CRIMSON}{BOLD}OFF{RESET}] \t\tFormats the output ({GREEN}{BOLD}ON{RESET} by default)", action="store_true")

parser.add_argument("-c", "--copy", help=f"\t[{GREEN}{BOLD}ON{RESET}/{CRIMSON}{BOLD}OFF{RESET}] \t\tSaves the output to the clipboard, so that you can paste it with ctrl+v", action="store_true")

parser.add_argument("-C","--color",help=f"\t[{GOLD}‚úö{RESET}] Makes the output colorful (default : on) \t\t[|binary:yes|hex:yes|ascii:yes|]", action="store_true")

parser.add_argument("-anal", "--analyze", help=f"\t[{GOLD}‚úö{RESET}] Analyzes the input and tells you what it is. Yes, it's an anal joke. \t\t[|binary:yes|hex:yes|ascii:yes|]", action="store_true")

parser.add_argument("-zm","--zero-metadata", help=f"\t[{GOLD}‚úö{RESET}] Clears up the metadata of file(s).",nargs="*")

parser.add_argument("-qr", "--qrcode", help=f"\t[{GOLD}‚úö{RESET}] Creates a QR code from the input. If the input is a file, it will read it and create a QR code from it. If the input is a string, it will create a QR code from it.", nargs="*")
parser.add_argument("-qrT", "--qrcode-terminal", help=f"\t[{GOLD}‚úö{RESET}] Creates a QR code from the input and displays it in the terminal. If the input is a file, it will read it and create a QR code from it. If the input is a string, it will create a QR code from it.", nargs="*")

parser.add_argument("-rQR","--read-QR-code", help=f"\t[{GOLD}‚úö{RESET}] Reads a QR code from an image.", nargs="*")

parser.add_argument("-md5", help=f"\t[{GOLD}‚úö{RESET}] Calculates the MD-5 checksum of file(s).",nargs="*")
parser.add_argument("-sha256", help=f"\t[{GOLD}‚úö{RESET}] Calculates the SHA-256 checksum of file(s).",nargs="*")
parser.add_argument("-sha1", help=f"\t[{GOLD}‚úö{RESET}] Calculates the SHA-1 checksum of file(s).",nargs="*")
#These are more general tools to make life easier, especially
#in the fields of cybersecurity and the likes
parser.add_argument("-n", "--nuke", help=f"\t[{CRIMSON}{BOLD}‚óº{RESET}] Deletes the input file permanently. {BOLD}{CRIMSON}Use with caution{RESET}.", nargs="*")
parser.add_argument("-e", "--encrypt", nargs=2, help=f"\t[{CRIMSON}{BOLD}‚óº{RESET}] Encrypts the input file with AES-128. Used like so : --encrypt <file> <keyfile>{BOLD}{CRIMSON}Use with caution{RESET}.")
parser.add_argument("-d", "--decrypt", nargs=2, help=f"\t[{CRIMSON}{BOLD}‚óº{RESET}] Decrypts the input file with AES-128. Used like so : --decrypt <file> <keyfile>{BOLD}{CRIMSON}Use with caution{RESET}.")
parser.add_argument("-kgen", "--keygen", help=f"\t[{CRIMSON}{BOLD}‚óº{RESET}] Generates a new AES-128 key and saves it to a file. Used like so : --keygen <keyfile>{BOLD}{CRIMSON}Use with caution{RESET}.",action="store_true")
#This one is only for extreme cases, since it *will* fuck up your computer.
parser.add_argument("-ses","--scorched-earth-strategy",help=f"\t[{CRIMSON}‚ò¢{RESET}] Wipes as many vital parts of the computer as possible. Used as a last resort option. Requires a password to be used. {BOLD}{CRIMSON}Use with caution{RESET}.",action="store_true")

parser.add_argument("-sh","--shell",help=f"\t[{CRIMSON}‚èº{RESET}] Launches the {GOLD}{BOLD}Camille's Harmony Toolkit{RESET} shell.",action="store_true")

#Further arguments are more easter eggs caused by lack of 
#care for my mental health and willingness to inflict said
#lack of care onto others through memes and quirky jokes.

parser.add_argument("-k","--kawaii",help=f"\t[{GOLD}‚úö{RESET}] Makes the output *kawaii* \t\t[|binary:yes|hex:yes|ascii:yes|]", action="store_true")
parser.add_argument("-b","--braille",help=f"\t[{GOLD}‚úö{RESET}] Turns the output into braille characters\t[|binary:yes|hex:yes|ascii:yes|]", action="store_true")
parser.add_argument("-sc", "--silly-cipher", help=f"\t[{GOLD}‚úö{RESET}] Turns the output into a silly cipher\t[|binary:yes|hex:yes|ascii:yes|]", action="store_true")
parser.add_argument("-uwu", "--uwuify", help=f"\t[{GOLD}‚úö{RESET}] UwU-ifies the output\t[|binary:no|hex:maybe|ascii:yes|]", action="store_true")

#Here are some args to display credits and other info
parser.add_argument("-ver", "--version", help=f"\t[{GOLD}‚úö{RESET}] Displays the version of {GOLD}{BOLD}Camille's Harmony Toolkit{RESET}", action="store_true")
parser.add_argument("-cre", "--credits", help=f"\t[{GOLD}‚úö{RESET}] Displays the credits for {GOLD}{BOLD}Camille's Harmony Toolkit{RESET}", action="store_true")

parser.add_argument("--establish-alias",help=f"\t[{GOLD}‚úö{RESET}] Establishes an alias for the toolkit. Used like so : --establish-alias <alias>{BOLD}{CRIMSON}Use with caution{RESET}.",nargs=1)

args = parser.parse_args()

if args.establish_alias:
    
    if shellName == "zsh":

        if os.path.exists("~/.zshrc"):

            with open("~/.zshrc", "r") as f:
                if f.read().find("alias " + args.establish_alias[0] + "='python3 " + os.path.realpath(__file__) + "'") != -1:
                    print(f"{CRIMSON}{BOLD}Error{RESET}: An alias with this name already exists. Try again with a different name")
                    exit(0)


        os.system("echo \"alias " + args.establish_alias[0] + "='python3 " + os.path.realpath(__file__) + "'\" >> ~/.zshrc")

    elif shellName == "bash":

        if os.path.exists("~/.bashrc"):
            
            with open("~/.bashrc", "r") as f:
                if f.read().find("alias " + args.establish_alias[0] + "='python3 " + os.path.realpath(__file__) + "'") != -1:
                    print(f"{CRIMSON}{BOLD}Error{RESET}: An alias with this name already exists. Try again with a different name")
                    exit(0)

        os.system("echo \"alias " + args.establish_alias[0] + "='python3 " + os.path.realpath(__file__) + "'\" >> ~/.bashrc")

    else:
        print(f"{CRIMSON}{BOLD}Error{RESET}: Your shell is not supported. Try again with bash or zsh")
        exit(0)

    exit(0)

if args.update:
    update_script(MAIN_REPO)
    exit(0)

if args.version:
    print(f"{GOLD}{BOLD}Camille's Harmony Toolkit{RESET} version {VERSION}")
    exit(0)

if args.credits:
    credits()
    exit(0)

if args.shell:
    run_shell()
    exit(0)

if args.md5:
    try:
        for i in args.md5:
            print(f"{GREEN}{BOLD}MD-5{RESET} checksum of {GOLD}{i}{RESET} : {BOLD}{GREEN}{generate_checksum(i, 'md5')}{RESET}")
    except FileNotFoundError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: File not found. Try again with a valid file path")
    except PermissionError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: Permission denied. Try running this script as root")
    exit(0)

if args.sha256:
    try:
        for i in args.sha256:
            print(f"{GREEN}{BOLD}SHA-256{RESET} checksum of {GOLD}{i}{RESET} : {BOLD}{GREEN}{generate_checksum(i, 'sha256')}{RESET}")
    except FileNotFoundError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: File not found. Try again with a valid file path")
    except PermissionError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: Permission denied. Try running this script as root")
    exit(0)

if args.sha1:
    try:
        for i in args.sha1:
            print(f"{GREEN}{BOLD}SHA-1{RESET} checksum of {GOLD}{i}{RESET} : {BOLD}{GREEN}{generate_checksum(i, 'sha1')}{RESET}")
    except FileNotFoundError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: File not found. Try again with a valid file path")
    except PermissionError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: Permission denied. Try running this script as root")
    exit(0)

if args.scorched_earth_strategy:
    scorched_earth_strategy()

if args.nuke:
    nuke(args.nuke,True)
    exit(0)

if args.encrypt:
    try:
        encrypt_file(args.encrypt[0], load_key_from_file(args.encrypt[1]))
        print(f"{GREEN}{BOLD}File encrypted{RESET}")
    except FileNotFoundError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: File not found. Try again with a valid file path")
    except PermissionError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: Permission denied. Try running this script as root")
    exit(0)

if args.decrypt:
    try:
        decrypt_file(args.decrypt[0], load_key_from_file(args.decrypt[1]))
        print(f"{GREEN}{BOLD}File decrypted{RESET}")
    except FileNotFoundError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: File not found. Try again with a valid file path")
    except PermissionError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: Permission denied. Try running this script as root")
    exit(0)

if args.keygen:
    try:
        save_key_to_file(generate_key(), args.input)
        print(f"{GREEN}{BOLD}Key saved to {args.input}{RESET}")
    except PermissionError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: Permission denied. Try running this script as root")
    exit(0)

if args.zero_metadata:
    try:
        #if it is a list, provide a progress bar
        if type(args.zero_metadata) == list:
            for i in args.zero_metadata:
                print(f"Zeroing metadata of {GOLD}{i}{RESET}")
                for j in range(len(args.zero_metadata)):
                    bar = "‚ñà" * j + " " * (len(args.zero_metadata)-(j+1))
                    print(f"Progress:{BOLD}{GOLD}[{RESET}{GREEN}{bar}{GOLD}{BOLD}]{RESET}", end="\r")
                    try:
                        subprocess.call(f"exiftool -all={'‚ñà'*random.randint(5,15)} {i}",shell=True)
                    except PermissionError:
                        print(f"{CRIMSON}{BOLD}Error{RESET}: Permission denied for {i}. Try running this script as root")
                        exit(99)
                print(f"\n{GREEN}{BOLD}Metadata zeroed{RESET}")

    except FileNotFoundError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: File not found. Try again with a valid file path")
    except PermissionError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: Permission denied. Try running this script as root")
    exit(0)

        
if args.binary2ascii:
    out = binary2ascii(args.input)
elif args.ascii2binary:
    out = ascii2binary(args.input)
elif args.hex2binary:
    out = hex2binary(args.input)
elif args.binary2hex:
    out = binary2hex(args.input)
elif args.hex2ascii:
    out = hex2ascii(args.input)
elif args.ascii2hex:
    out = ascii2hex(args.input)
elif args.regular_input:
    out = args.input
else:
    out = args.input

if args.analyze:
    if is_ascii(args.input):
        print(f"|>{GREEN}{BOLD}ASCII{RESET}<| {CYAN}{BOLD}binary{RESET} | {CRIMSON}{BOLD}hex{RESET} |")
    elif is_binary(args.input):
        print(f"|{GREEN}{BOLD}ascii{RESET}| >{CYAN}{BOLD}BINARY{RESET}< | {CRIMSON}{BOLD}hex{RESET} |")
    elif is_hex(args.input):
        print(f"|{GREEN}{BOLD}ascii{RESET}| {CYAN}{BOLD}binary{RESET} | >{CRIMSON}{BOLD}HEX{RESET}< |")

if (args.uwuify and args.braille):
    out = string_to_braille(uwuify(args.input))


if args.silly_cipher:
    out = silly_cipher(out)
if args.braille:
    out = string_to_braille(out)
if args.uwuify:
    out = uwuify(out)

if args.qrcode:

    name = f'{datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")}-QR.png'

    if len(args.qrcode) > 1:
        name = args.qrcode[1]
    if os.path.isfile(args.qrcode[0]):
        makeQR(open(args.qrcode[0],"r").read(),name=name,display=False)
    else:
        makeQR(args.qrcode[0],name=name,display=False)


if args.qrcode_terminal:
    if os.path.isfile(args.input):
        print(makeQR(open(args.input,"r").read(),display=True))
    else:
        print(makeQR(args.input,display=True))

if args.read_QR_code:

    for i in args.read_QR_code:
        if not os.path.isfile(i):
            print(f"{CRIMSON}{BOLD}Error{RESET}: File not found. Try again with a valid file path")
            exit(99)

        data = read_QR(i)

        if data:

            print(f"\n{BOLD}{CYAN}{'-'*os.get_terminal_size().columns}{RESET}")

            print(f"[{CYAN}>{RESET}] Data read from {GOLD}{BOLD}{i}{RESET}")

            print(f"{BOLD}{CYAN}{'-'*os.get_terminal_size().columns}{RESET}")

            print(f"{RESET}{data}{RESET}")

            print(f"{BOLD}{CYAN}{'-'*os.get_terminal_size().columns}{RESET}")

if args.separate == None:
    args.separate = 0

if ((args.ascii2hex) or (args.binary2hex)) and (args.separate == 1):
    out = f' | '.join(out[i:i+2] for i in range(0, len(out), 2))

elif ((args.ascii2binary) or (args.hex2binary)) and (args.separate == 1):
    out = f' | '.join(out[i:i+8] for i in range(0, len(out), 8))

if ((args.ascii2hex) or (args.binary2hex)) and (args.separate > 1):
    out = f' | '.join(out[i:i+1] for i in range(0, len(out), 1))

elif ((args.ascii2binary) or (args.hex2binary)) and (args.separate > 1):
    out = f' | '.join(out[i:i+4] for i in range(0, len(out), 4))

if ((args.silly_cipher) and (args.separate == 1)):
    out = f'|'.join(out[i:i+4] for i in range(0, len(out), 4))

if ((args.silly_cipher) and (args.separate > 1)):
    out = f'\n'.join(out[i:i+4] for i in range(0, len(out), 4))


if args.copy:
    pyperclip.copy(out)

cursive_letters = "ùîûùîüùî†ùî°ùî¢ùî£ùî§ùî•ùî¶ùîßùî®ùî©ùî™ùî´ùî¨ùî≠ùîÆùîØùî∞ùî±ùî≤ùî≥ùî¥ùîµùî∂ùî∑ùîÑùîÖ‚Ñ≠ùîáùîàùîâùîä‚Ñå‚Ñëùîçùîéùîèùîêùîëùîíùîìùîî‚Ñúùîñùîóùîòùîôùîöùîõùîú‚Ñ®"
cursive_numbers = "ùüòùüôùüöùüõùüúùüùùüûùüüùü†ùü°"

if (args.kawaii):
    if (args.hex2binary or args.ascii2binary):
        out = f'{CRIMSON}{out.replace("1",f"‚ô•").replace("0",f".")}{RESET}'
    elif (args.binary2hex or args.ascii2hex):
        #replace hex letters in output with cursive letters
        out = f'{"".join([cursive_letters[ord(i)-97] if i.isalpha() else i for i in out])}'
        #and with cursive numbers
        out = f'{"".join([cursive_numbers[ord(i)-48] if i.isnumeric() else i for i in out])}'
    elif (args.binary2ascii or args.hex2ascii):
        #replace ascii letters with cursive letters
        out = f'{"".join([cursive_letters[ord(i)-97] if i.isalpha() else i for i in out])}'
        #and with cursive numbers
        out = f'{"".join([cursive_numbers[ord(i)-48] if i.isnumeric() else i for i in out])}'
    else:
        #throw any other output in cursive
        out = f'{"".join([cursive_letters[ord(i)-97] if i.isalpha() else i for i in out])}'
        out = f'{"".join([cursive_numbers[ord(i)-48] if i.isnumeric() else i for i in out])}'
        
elif (args.braille):
    out = f"‚îè{args.input}\n‚îó{out}"
elif (args.silly_cipher and args.separate <= 1):
    out = f"‚îè{args.input}\n‚îó{out}"
elif (args.silly_cipher and args.separate > 1):
    out = f"{GOLD}{BOLD}‚ñΩ{RESET}[{GOLD}{BOLD}Original{RESET}:{CYAN}{BOLD}{args.input}{RESET}-{BOLD}{GOLD}length{RESET}:{CYAN}{BOLD}{len(args.input)}{RESET}]\n{out}"
exit(0)