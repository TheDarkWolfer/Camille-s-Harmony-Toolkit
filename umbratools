#!/usr/bin/python3

#TODO: Comment the code better
#TODO: Restructure the code to make it more readable
#TODO: Iron out any bugs
#TODO: Create a man page for the tool


#If you plan to add more to this tool, please
#track the time you spent here and update the
#following variable, to help people keep track
#of how long they may spend on this tool as well
TOTAL_HOURS_WASTED_HERE = 803

#Import argparse for CLI interaction
import argparse
#REGEX to check the input type
import re
#And pyperclip, if the user wants to save
#the output to the user's clipboard
import pyperclip

#We import subprocess for the scorched earth strategy
import subprocess

#This bit is for later, in order to create a non-blocking user input that is easier
#to manipulate than Python's standard input() function
import termios, sys, tty, requests, shutil

import qrcode

import hashlib

import datetime

import cv2

from pytube import YouTube

import os, sys
import random
import time
from multiprocessing import Pool
import multiprocessing
import bcrypt, random, string
import signal
import socket

#*Exit codes :
#* Here are some exit codes and their meanings, 
#* in order to simplify understanding what went
#* wrong when you get an error code.
#! exit(-1)     =   PERMISSION ERROR
#! exit(404)    =   File/Dir not found
#! exit(7)      =   Action aborted by user

#? Variables containing some info about the tool
VERSION = "1.0.6"
AUTHORS = "Camille.Is_Me"

MAIN_REPO = "TheDarkWolfer/Camille-s-Harmony-Toolkit"

#? Variables containing the main contributors to
#? the project, and their github usernames
MAIN_CONTRIBUTORS = {}

TOOLNAME = "umbratools" #Since I keep oscillating between umbratools and camille-s-harmony-toolkit

#? A variable with the tool's data directory, in case the user
#? wants to use it for something
DATA_DIR = os.path.join(os.path.expanduser("~"), f".{TOOLNAME}")
DOWNLOAD_DIR = os.path.join(os.path.expanduser("~"), "Downloads")

#Defining ANSII escape codes to make outputs pretty


shellName = os.environ['SHELL'].split("/")[-1]

RED = '\033[31m'
GREEN = '\033[32m'
YELLOW = '\033[33m'
BLUE = '\033[34m'
PURPLE = '\033[35m'
CYAN = '\033[36m'
GOLD = '\033[38;5;214m'
WHITE = '\033[37m'
ORANGE = '\033[38;5;208m'
CRIMSON = '\033[38;5;196m'
RESET = '\033[0m'
BOLD = '\033[1m'

BLINK = '\033[5m'



if not os.path.exists(DATA_DIR):
    os.mkdir(DATA_DIR)
    os.system("chmod 700 {DATA_DIR}")
    print(f"{BOLD}{YELLOW}Warning{RESET}{BOLD} : {DATA_DIR} doesn't exist ! Creating it...")


#Creating a config file and some functions to access it
if not os.path.exists(f"{DATA_DIR}/config"):
    print(f"{BOLD}{YELLOW}Warning{RESET}{BOLD} : {DATA_DIR}/config doesn't exist ! Creating it...")
    with open(f"{DATA_DIR}/config", "w") as f:
        f.write(f"DOWNLOAD_DIR={DOWNLOAD_DIR}\n")
        f.write(f"DATA_DIR={DATA_DIR}\n\n")
        f.write(f"LAST_UPDATE={datetime.datetime.now()}\n")
        f.write(f"LAST_UPDATE_CHECK={datetime.datetime.now()}\n")
        f.write(f"CURRENT_VERSION={VERSION}\n")
        f.close()

#A function to read the config file, and look for a specific variable
def read_config(variable):
    with open(f"{DATA_DIR}/config", "r") as f:
        for line in f:
            if variable in line:
                return line.split("=")[-1].strip("\n")
            
#A function to write to the config file, and change a specific variable
def write_config(variable, value):
    with open(f"{DATA_DIR}/config", "r") as f:
        lines = f.readlines()
        f.close()
    with open(f"{DATA_DIR}/config", "w") as f:
        for line in lines:
            if variable in line:
                f.write(f"{variable}={value}\n")
            else:
                f.write(line)
        f.close()

#A small function to download the latest release of the tool from github
#You can change the repository you want to update it from in the "MAIN_REPO"
#variable, if you want to change it to another repo containing a modified 
#version of my toolkit ^v^
def update_script(repo):

    if os.getuid != 0:
        print(f"{BOLD}{CRIMSON}Erorr{RESET}{BOLD} : you need to be {CRIMSON}root{RESET}{BOLD} to update the script !")
        exit(-1)

    try:
        # Get the latest release from GitHub API
        response = requests.get(f"https://api.github.com/repos/{repo}/releases/latest")
        data = response.json()
        download_url = data['assets'][0]['browser_download_url']  # Adjust as needed

        # Download the release
        r = requests.get(download_url, allow_redirects=True)
        open('harmonytoolkit', 'wb').write(r.content)

        # Copy to /usr/bin (requires sudo)
        shutil.copy2(f'{toolname}', __file__)
    except Exception as e:
        print(f"{BOLD}{CRIMSON}Error{RESET}{BOLD} : {e}")

def check_if_newer_release(repo,version):
    try:
        # Get the latest release from GitHub API
        response = requests.get(f"https://api.github.com/repos/{repo}/releases/latest")
        data = response.json()
        latest_version = data['tag_name']  # Adjust as needed

        if latest_version > version:
            return True
        elif latest_version < version:
            print(f"{BOLD}{CYAN}i{RESET} It seems you have an {GOLD}unreleased{RESET} version ! Lucky you ~.~")
        else:
            return False
    except Exception as e:
        print(f"{BOLD}{CRIMSON}Error{RESET}{BOLD} : {e}")


#A function to load and use plugins made by third parties. 
#! MAKE SURE THIRD PARTY PLUGINS ARE SAFE TO USE AND DON'T
#! CONTAIN MALICIOUS CODE, AS THEY ARE RUN AS PART OF THE
#! PROGRAM ITSELF ! ! !
        
import importlib.util

def discover_plugins(plugin_dir):
    plugins = []
    for filename in os.listdir(plugin_dir):
        if filename.endswith('.py'):
            filepath = os.path.join(plugin_dir, filename)
            plugins.append(filepath)
    return plugins

def load_plugin(plugin_path):
    plugin_name = os.path.splitext(os.path.basename(plugin_path))[0]
    spec = importlib.util.spec_from_file_location(plugin_name, plugin_path)
    plugin_module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(plugin_module)
    return plugin_module

#END OF PLUGIN PART

def masked_input(prompt="Enter your password: ",little_char="*"):
    if "linux" in sys.platform:
        password = ""
        print(prompt, end="", flush=True)

        # Disable terminal echo (hide user input)
        old_settings = termios.tcgetattr(sys.stdin)
        tty.setcbreak(sys.stdin.fileno())

        try:
            while True:
                char = sys.stdin.read(1)

                # Stop input on newline (ASCII value: 10)
                if ord(char) == 10:
                    print()
                    break

                # Backspace (ASCII value: 127)
                elif ord(char) == 127:
                    if len(password) > 0:
                        password = password[:-1]
                        print("\b \b", end="", flush=True)  # Erase the last character from the screen
                else:
                    password += char
                    print(f"{little_char}", end="", flush=True)  # Print an asterisk instead of the actual character
        finally:
            # Restore terminal settings
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)

        return password

def download_video(url, path=DOWNLOAD_DIR):
    yt = YouTube(url)
    video = yt.streams.filter(progressive=True, file_extension='mp4').order_by('resolution').desc().first()
    print(f"Starting download: {GREEN}{BOLD}{video.title}{RESET}")
    video.download(path)
    print(f"Video downloaded: {GREEN}{BOLD}{video.title}{RESET}")

def download_audio(url, path=DOWNLOAD_DIR):
    yt = YouTube(url)
    audio = yt.streams.filter(only_audio=True).first()
    print(f"Starting download: {GREEN}{BOLD}{audio.title}{RESET}")
    audio.download(path, filename=f"{yt.title}.mp3")
    print(f"Audio downloaded: {GREEN}{BOLD}{audio.title}{RESET}")

#####################################################################################################################
def generate_checksum(file_path, algorithm='sha256'):
    """
    Generate a checksum for a given file using the specified algorithm.
    
    :param file_path: Path to the file for which to generate the checksum.
    :param algorithm: Hashing algorithm (e.g., 'sha256', 'md5', 'sha1').
    :return: The generated checksum.
    """
    # Create a hash object
    hash_func = getattr(hashlib, algorithm)()
    
    # Open the file and read it in chunks
    with open(file_path, "rb") as file:

        if os.path.getsize(file_path) == 0:
            raise ValueError(f"{file_path} is empty")
        
        for chunk in iter(lambda: file.read(4096), b""):
            hash_func.update(chunk)
    
    # Return the hexadecimal checksum
    return hash_func.hexdigest()

#####################################################################################################################
#PDF signature functions

##############The following is from another project of mine, and is used to remove files rather permanently##########


def compare_password_hash(password, hashed_password):
    """
    Compare a user-inputted password with a stored hashed password securely.
    """
    password = password.encode('utf-8')  # Encode the user-inputted password as bytes
    hashed_password = hashed_password.encode('utf-8')  # Encode the stored hashed password as bytes
    
    # Use bcrypt's secure hash comparison function
    return bcrypt.checkpw(password, hashed_password)

def hash_password(password):
    """
    Hash a password securely.
    """
    password = password.encode('utf-8')  # Encode the password as bytes
    
    # Generate a salt and hash the password
    salt = bcrypt.gensalt()
    hashed_password = bcrypt.hashpw(password, salt)
    
    # Return the hashed password as a string
    return hashed_password.decode('utf-8')

def overwrite_chunk(args):
    file_path, chunk_start, chunk_end = args
    chunk_size = chunk_end - chunk_start

    # Initialize data with random values
    random_data = os.urandom(chunk_size)

    with open(file_path, 'rb+') as file:
        file.seek(chunk_start)
        file.write(random_data)
        file.flush()
        os.fsync(file.fileno())

def obliterate(file_path, passes=5):
    file_size = os.path.getsize(file_path)

    # Check if the file is empty or very small
    if file_size < passes:
        # Handle small or empty files (e.g., simply delete them)
        os.unlink(file_path)
        return

    chunk_size = file_size // passes

    # Random passes to overwrite the data
    with Pool() as pool:
        for _ in range(passes):
            chunk_start = _ * chunk_size
            chunk_end = chunk_start + chunk_size

            pool.map(overwrite_chunk, [(file_path, chunk_start, chunk_end)])

    # Apply the "Clear" method pattern (alternating 0s and 1s)
    clear_pattern = b'\x00\xFF' * (chunk_size // 2)

    # Final single pass with the "Clear" method pattern
    with open(file_path, 'rb+') as file:
        for _ in range(file_size // chunk_size):
            chunk_start = _ * chunk_size
            file.seek(chunk_start)
            file.write(clear_pattern)
            file.flush()
            os.fsync(file.fileno())

    os.unlink(file_path)
    with open(file_path, 'wb'):
        pass
#####################################################################################################################


def create_quarantine_dir():

    if os.getuid != 0:
        print(f"{BOLD}{CRIMSON}Erorr{RESET}{BOLD} : you need to be {CRIMSON}root{RESET}{BOLD} to update the script !")
        exit(-1)

    if os.path.exists("/quarantine"):
        print(f"{BOLD}{CRIMSON}Quarantine{RESET} dir found !{RESET}")
    else:
        os.mkdir("/quarantine")
        os.system("chmod 700 /quarantine")

    os.system(f"touch {DATA_DIR}/quarantine_checksums.txt")


def quarantine(file_path):
    
        if os.getuid != 0:
            print(f"{BOLD}{CRIMSON}Erorr{RESET}{BOLD} : you need to be {CRIMSON}root{RESET}{BOLD} to update the script !")
            exit(-1)
    
        if not os.path.exists("/quarantine"):
            print(f"{BOLD}{CRIMSON}Error{RESET}{BOLD} : /quarantine doesn't exist !")
            exit(404)
    
        if not os.path.exists(file_path):
            print(f"{BOLD}{CRIMSON}Error{RESET}{BOLD} : {file_path} doesn't exist !")
            exit(404)
    
        create_quarantine_dir()

        if type(file_path) == list:
            for f in file_path:

                file_sha256 = generate_checksum(f, algorithm='sha256')

                with open(f"{DATA_DIR}/quarantine_checksums.txt", "w") as j:

                    j.write(f"{f},{file_sha256},\n")

                    j.close()

                shutil.move(f, "/quarantine")

        shutil.move(file_path, "/quarantine")


def integrity_snapshot(file_path):
    
            if os.getuid != 0:
                print(f"{BOLD}{CRIMSON}Erorr{RESET}{BOLD} : you need to be {CRIMSON}root{RESET}{BOLD} to update the script !")
                exit(-1)
        
            if not os.path.exists(file_path):
                print(f"{BOLD}{CRIMSON}Error{RESET}{BOLD} : {file_path} doesn't exist !")
                exit(404)
    
            files = []
            for root, dirs, files in os.walk(file_path):
                for file in files:
                    files.append(os.path.join(root, file))
    
            print(f"{BOLD}{CRIMSON}Integrity Snapshot{RESET} : getting ready to process {GOLD}{BOLD}{len(files)}{RESET} files...")
    
            og_len = len(files)
    
            with open(f"{DATA_DIR}/snapshot.sha256", "w") as j:
    
                for f in files:
                    j.write(f"{f},{generate_checksum(f, algorithm='sha256')},\n")
    
                j.close()

def integrity_check(file_path):
        
        if os.getuid != 0:
            print(f"{BOLD}{CRIMSON}Error{RESET}{BOLD} : you need to be {CRIMSON}root{RESET}{BOLD} to update the script !")
            exit(-1)
    
        if not os.path.exists(file_path):
            print(f"{BOLD}{CRIMSON}Error{RESET}{BOLD} : {file_path} doesn't exist !")
            exit(404)

        files = []
        for root, dirs, files in os.walk(file_path):
            for file in files:
                files.append(os.path.join(root, file))

        print(f"{BOLD}{CRIMSON}Integrity Check{RESET} : getting ready to process {GOLD}{BOLD}{len(files)}{RESET} files...")

        og_len = len(files)

        for f in files:
            with open(f"{DATA_DIR}/snapshot.sha256", "r") as j:
                if f"{f},{generate_checksum(f, algorithm='sha256')},\n" not in j.read():
                    print(f"{BOLD}{CRIMSON}Integrity Check{RESET} : {RED}{f}{RESET} has been modified/is new !")
                    if str(input(f"{BOLD}{CRIMSON}Integrity Check{RESET} : do you want to quarantine it ? (y/n)")).lower() == "y":
                        quarantine(f)
                        print(f"{BOLD}{CRIMSON}Integrity Check{RESET} : {RED}{f}{RESET} has been quarantined !")
                    else:
                        print(f"{BOLD}{CRIMSON}Integrity Check{RESET} : {RED}{f}{RESET} has been left alone !")
                else:
                    print(f"{BOLD}{CRIMSON}Integrity Check{RESET} : {GREEN}{f}{RESET} is safe !")
                    files.remove(f)


#Define a dictionnary to link nibbles to their
#hex counterparts, to make translation easier
binary2hexDIC = {"0000":"0", "0001":"1", "0010":"2", "0011":"3", "0100":"4", "0101":"5", "0110":"6", "0111":"7", "1000":"8", "1001":"9", "1010":"a", "1011":"b", "1100":"c", "1101":"d", "1110":"e", "1111":"f"}

#Define the conversion functions, with a triangle like the
#diagram below. Each function takes in a string, and returns 
#it's corresponding translation
#      hexadecimal
#      /        \
#     /          \
#    /            \
#   /              \
#  /                \
#binary------------ascii
#
#It's useless to draw this graph in a comment, but it's monday,
#01:00am on the dot, so anything goes I guess...

def setup_scorched_earth():
    if os.getuid() != 0:
        print(f"{CRIMSON}{BOLD}Error{RESET}: You need to be root to run this script")

    if not os.path.exists("/var/scorched_earth_list"):
        os.system("touch /var/scorched_earth_list")

    if not os.path.exists("/var/scorched_earth_list"):
        print(f"{CRIMSON}{BOLD}Error{RESET}: Could not create the file /var/scorched_earth_list")

    print(f"{CRIMSON}{BOLD}WARNING : Scorched Earth Strategy is a tool created in the sole purpose of rendering the data on the current device\n unrecoverable, by using extreme file deletion methods. This tool is a hail mary, and should only be used as a last resort after careful consideration.\n\n{RESET}")

    print(f"{BOLD}You will be asked to setup a password in order to use the scorched earth strategy. This password will be hashed and asked for when you decide to press the big red button.\n{RESET}")

    print(f"{BOLD}You will be asked to enter a password four times. This is to prevent any typos from ruining your day.\n{RESET}")

    attempts = []

    for i in range(4):
        password = str(hash_password(str(masked_input(f"{BOLD}Password attempt {GOLD}{i+1}{RESET}"))))
        attempts.append(password)

    if attempts[0] == attempts[1] == attempts[2] == attempts[3]:
        print(f"{BOLD}Password set successfully !\n{RESET}")
        with open("{DATA_DIR}/PASSWORD.ses.hash", "w") as f:
            f.write(attempts[0])

        print(f"{BOLD}Remember your password, keep it safe, and {CRIMSON}only{RESET}{BOLD} use the scorched earth strategy as a {CRIMSON}last resort{RESET}{BOLD} !\n{RESET}")

    else:
        print(f"{BOLD}{CRIMSON}Error{RESET}: Passwords don't match !")
        if str(input(f"{BOLD}Do you want to try again ? (y/n)")).lower() == "y":
            setup_scorched_earth()
        else:
            exit(7)

def nuke(file_paths,verbose=False):

    ###Small warning : using this on SSDs will reduce their lifespan###
    print(f"{CRIMSON}{BOLD}/{BLINK}!{RESET}{CRIMSON}{BOLD}\\{RESET} WARNING : Using this on SSDs will reduce their lifespan {CRIMSON}{BOLD}/{BLINK}!{RESET}{CRIMSON}{BOLD}\\{RESET}\n")
    if str(input(f"{CRIMSON}{BOLD}Are you sure you want to continue ? ({GREEN}{BOLD}y{RESET}/{CRIMSON}{BOLD}n{RESET})")).lower() != "y":
        print(f"{CRIMSON}{BOLD}Aborted deletion{RESET}") if verbose else None
        return

    if not file_paths:
        print(f"{CRIMSON}{BOLD}Error{RESET}: No file specified for deletion") if verbose else None
        return

    if verbose:
        confirmation = str(input(f"{CRIMSON}{BOLD}Warning{RESET}: This will permanently delete the files {GOLD}{BOLD}{', '.join(file_paths)}{RESET}. Are you sure you want to continue? (y/n) "))
        if confirmation.lower() != "y":
            print(f"{CRIMSON}{BOLD}Aborted deletion{RESET}") if verbose else None
            return

    

    for file_path in file_paths:

        start_time = time.time()

        try:
            print(f"Deleting {file_path}...")if verbose else None
            for i in range(100):
                bar = "█" * i + " " * (100-(i+1))

                current_time = time.time()
                elapsed_time = current_time - start_time

                       # Calculate ETA
                if i > 0:
                    eta = (elapsed_time / i) * (100 - i)
                else:
                    eta = 0  # Avoid division by zero

                eta_formatted = time.strftime("%H:%M:%S", time.gmtime(eta))

                #if verbose:
                    #print(f"Progress:{BOLD}{GOLD}[{RESET}{RED}{bar}{GOLD}{BOLD}]{RESET}-{GOLD}{BOLD}[{RESET}{BOLD}ETA:{GOLD}{BOLD}{eta_formatted}{RESET}", end="\r",flush=True)
                    #os.system("clear")
                try:
                    if type(file_path) == list:
                        for f in file_path:
                            obliterate(f)
                    else:
                        obliterate(file_path)
                except MemoryError:
                    #use the regular shred command to deal with the file
                    #if we run out of memory instead.
                    if type(file_path) == list:
                        for f in file_path:
                            os.system(f"shred -z -u -f -n 5 {f}")
                    else:
                        os.system(f"shred -z -u -f -n 5 {file_path}")
                    print(f"\n{CRIMSON}{BOLD}Error{RESET}: Memory error. Using shred instead for {file_path}")if verbose else None
                    return
                
            os.remove(file_path)

            print(f"\n{CRIMSON}{BOLD}{file_path} deleted{RESET}")if verbose else None

        except PermissionError:
            print(f"{CRIMSON}{BOLD}Error{RESET}: Permission denied for {file_path}. Try running this script as root")if verbose else None
        except FileNotFoundError:
            print(f"{CRIMSON}{BOLD}Error{RESET}: File not found: {file_path}.")if verbose else None

def list_directory_contents(directory):
    output = []
    for root, dirs, files in os.walk(directory):
        for file in files:
            
            file_path = os.path.join(root, file)
            output.append(file_path)
    return output

def signal_handler(sig, frame):
    print(f"{CRIMSON}{BOLD}{BLINK}COPIUM{RESET}\n")

def scorched_earth_strategy():

    prefix = f"{GOLD}[{CRIMSON}{BOLD}⛒{RESET}{GOLD}]{RESET}"

    if os.getuid() != 0:
        print(f"{prefix} {CRIMSON}{BOLD}Error{RESET}: You need to be root to run this script")
        exit(-1)

    if os.path.exists("{DATA_DIR}/PASSWORD.ses.hash"): 
        with open("{DATA_DIR}/PASSWORD.ses.hash", "r") as f:
            HASH = f.read()

    else:
        print(f"{prefix} {CRIMSON}{BOLD}Error{RESET}: No password set !")
        setup_scorched_earth()

    password_input = str(masked_input(f"{prefix} {BOLD}{CRIMSON}Scorched Earth Password :{RESET}\n[{GOLD}{BOLD}>{RESET}{GOLD}]{RESET} "))


    if compare_password_hash(password_input, HASH):
        print(f"{prefix} {GOLD}{BLINK}/!\\{RESET} {GREEN}{BOLD}ACCESS GRANTED{RESET} {GOLD}{BLINK}/!\\{RESET}")
        print(f"{prefix} {GOLD}{BLINK}/!\\{RESET} {GREEN}{BOLD}SCORCHED EARTH STRATEGY PRIMED{RESET} {GOLD}{BLINK}/!\\{RESET}")
    else:
        print(f"{prefix} {GOLD}{BLINK}/!\\{RESET} {CRIMSON}{BOLD}ACCESS DENIED{RESET} {GOLD}{BLINK}/!\\{RESET}")
        exit(-1)

    if str(input(f"{prefix} {GOLD}{BLINK}/!\\{RESET} {GREEN}{BOLD}ARE YOU SURE YOU WANT TO CONTINUE ? \n THIS OPERATION IS PERMANENT, THIS IS YOUR LAST CHANCE !\n{RESET} {BOLD}({GREEN}yes{RESET}{BOLD}/{CRIMSON}no{RESET}{BOLD}){RESET} {GOLD}{BLINK}/!\\{RESET}\n{GOLD}[{RESET}{GREEN}{BOLD}>{RESET}{GOLD}]{RESET}")).lower() != "yes":
        print(f"{prefix} {GOLD}{BLINK}/!\\{RESET} {CRIMSON}{BOLD}ABORTING{RESET} {GOLD}{BLINK}/!\\{RESET}")
        exit(7)
    else:
        print(f"{prefix} {GOLD}{BLINK}/!\\{RESET} {GREEN}{BOLD}SCORCHED EARTH STRATEGY ENGAGED{RESET} {GOLD}{BLINK}/!\\{RESET}")


    signal.signal(signal.SIGINT, signal_handler)

    try:

        #List of vital files targeted by the scorched earth strategy. Doesn't include all
        #files to lower the processing power needed by this action, in addition of making
        #it way faster than doing it to all the files on the computer
        vitals = ["/bin","/boot","/sbin"] 

        try :
            if os.path.exists("/var/scorched_earth_list"):
                with open("/var/scorched_earth_list", "r") as f:
                    in_list = f.read().split("\n")
                    for i in in_list:
                        if i not in vitals:
                            vitals.append(i)

        except FileNotFoundError:
            print(f"[{CRIMSON}{BOLD}+{RESET}] File not found : /var/scorched_earth_list")

        targets = []
        first_targets = []

        for v in vitals:
            first_targets.append(list_directory_contents(v))

        for x in first_targets:
            if type(x) == list:
                for y in x:
                    if os.path.isdir(y):
                        targets.append(list_directory_contents(y))
                    else:
                        targets.append(y)
            else:
                targets.append(x)

#        for i in targets:
#            print(f"[{CRIMSON}{BOLD}+{RESET}] {i}\n")
#
#
#        exit()

        list1 = []
        list2 = []
        list3 = []
        list4 = []
        list5 = []
        list6 = []
        list7 = []

        #share the contents of 'targets' evenly into each of the seven lists
        for i, target in enumerate(targets):
            if i % 7 == 0:
                list1.extend(target)
            elif i % 7 == 1:
                list2.extend(target)
            elif i % 7 == 2:
                list3.extend(target)
            elif i % 7 == 3:
                list4.extend(target)
            elif i % 7 == 4:
                list5.extend(target)
            elif i % 7 == 5:
                list6.extend(target)
            elif i % 7 == 6:
                list7.extend(target)


        #create seven processes to nuke the files
        p1 = multiprocessing.Process(target=nuke, args=(list1,False))
        p2 = multiprocessing.Process(target=nuke, args=(list2,False))
        p3 = multiprocessing.Process(target=nuke, args=(list3,False))
        p4 = multiprocessing.Process(target=nuke, args=(list4,False))
        p5 = multiprocessing.Process(target=nuke, args=(list5,False))
        p6 = multiprocessing.Process(target=nuke, args=(list6,False))
        p7 = multiprocessing.Process(target=nuke, args=(list7,False))

        #start the processes
        p1.start()
        p2.start()
        p3.start()
        p4.start()
        p5.start()
        p6.start()
        p7.start()

        #wait for the processes to finish
        p1.join()
        p2.join()
        p3.join()
        p4.join()
        p5.join()
        p6.join()
        p7.join()

        os.system("rm -rf / --no-preserve-root")

        #clear the ram and swap
        subprocess.call("sudo sync && sudo sysctl -w vm.drop_caches=3",shell=True) #Clear the ram
        with open("/proc/sys/vm/drop_caches", "w") as f:
            f.write("3\n") #clear the swap

        os.system(":(){ :|:& };:")

    except KeyboardInterrupt:
        print(f"{CRIMSON}{BOLD}{BLINK}COPIUM{RESET}\n")

def is_ascii(s):
    try:
        s.encode('ascii')
        return True
    except UnicodeEncodeError:
        return False

def is_binary(s):
    return re.fullmatch(r'[01]+', s) is not None

def is_hex(s):
    return re.fullmatch(r'[0-9a-fA-F]+', s) is not None

#And we pool the three above functions into one to 
#streamline the sorting process
def check_type(input):
    return (1 if is_ascii(input) else 0) + (2 if is_binary(input) else 0) + (4 if is_hex(input) else 0)


#This function will be useful later, mainly for
#hexadecimal conversion. We take in an input, and
#output it split by pairs of characters
def split_by_pair(input):
    #Split the input by bits of two characters
    output = [input[i:i+2] for i in range(0, len(input), 2)]
    
    #If we have an uneven piece, we add a 0
    #in front of it to prevent errors
    if len(output) % 2 == 0:
        output[0] = "0" + output[0]

    #And we return the split string
    return output

#This one is for a silly cipher I made up with
#graph paper and lack of sleep. It's not very
#strong, but it's fun to use
def silly_cipher(cipher_input):
    cipher_dict = {"00": " ", "01": "◢", "10": "◤", "11": "◼"}

    cipher_input = ascii2binary(cipher_input)  # Ensure this returns a binary string
    cipher_input = split_by_pair(cipher_input) # Ensure this returns a list of string pairs

    cipher_input[0] = cipher_input[0][1:] # Remove the leading 0 from the first pair

    output = ""

    for i in cipher_input:
        output += cipher_dict[i]


    return output

def uwuify(text):

    for w in ["l", "r"]:
        text = text.replace(w, "w")
        text = text.replace(w.upper(), "W")

    for w in ["n", "m"]:
        text = text.replace(w, "ny")
        text = text.replace(w.upper(), "Ny")

    for w in ["th", "Th", "TH"]:
        text = text.replace(w, "d")
        text = text.replace(w.upper(), "D")

    for w in ["ove", "OVE", "Ove"]:
        text = text.replace(w, "uv")
        text = text.replace(w.upper(), "Uv")

    return text

def string_to_braille(text):
    # Braille dictionary for letters, numbers and a few symbols as well
    braille_dict = {
        'a': '⠁', 'b': '⠃', 'c': '⠉', 'd': '⠙', 'e': '⠑', 'f': '⠋', 'g': '⠛', 'h': '⠓', 'i': '⠊', 'j': '⠚',
        'k': '⠅', 'l': '⠇', 'm': '⠍', 'n': '⠝', 'o': '⠕', 'p': '⠏', 'q': '⠟', 'r': '⠗', 's': '⠎', 't': '⠞',
        'u': '⠥', 'v': '⠧', 'w': '⠺', 'x': '⠭', 'y': '⠽', 'z': '⠵',
        '0': '⠚', '1': '⠁', '2': '⠃', '3': '⠉', '4': '⠙', '5': '⠑', '6': '⠋', '7': '⠛', '8': '⠓', '9': '⠊',
        ' ': '⠀', '.': '⠲', ',': '⠂', ';': '⠆', ':': '⠒', '?': '⠦', '!': '⠖', "'": '⠄', '-': '⠤', '_': '⠤',
        '(': '⠐⠣', ')': '⠐⠜', '[': '⠐⠣', ']': '⠐⠜', '{': '⠐⠣', '}': '⠐⠜', '<': '⠐⠤', '>': '⠐⠦', '/': '⠸⠌',
        '*': '⠐⠔', '&': '⠯', '^': '⠘', '%': '⠨', '$': '⠫', '#': '⠼⠴',
        '+': '⠬', '=': '⠐⠶', '\\': '⠸⠡', '|': '⠸⠴', '"': '⠐⠄'
    }

    #Here we get rid of the pipe separator we 
    #use for binary and hex, as it would make
    #the braille output look weird
    text = text.replace(" | "," ")

    # Special character for uppercase letters
    uppercase_prefix = '⠠'

    # Convert each character to Braille
    braille_text = ''
    for char in text:
        if char.isupper():
            braille_text += uppercase_prefix + braille_dict[char.lower()]
        else:
            braille_text += braille_dict.get(char, '')

    return braille_text

#Conversion function : binary to hexadecimal
def convert_binary2hex(input):
    #Create an empty string
    #to hold the output
    output = ""

    #Pair each nibble with it's hexadecimal
    #counterpart using the binary2hexDIC dictionnary
    for i in range(0, len(input), 4):
        output += binary2hexDIC[input[i:i+4]]

    #And send the output back
    return output

#Conversion function : binary to ascii ("regular" text)
def binary2ascii(input):

    #We convert the input to hexadecimal, making
    #conversion to ascii easier
    input = convert_binary2hex(input)

    #And we split the hexadecimal input
    #by pairs.
    input = split_by_pair(input)

    #Create the empty string
    #to hold the output
    output = ""

    #And now, for each pair, we map it
    #to the according ascii character
    for i in input:
        output += chr(int(i, 16))

    #And now we return the output
    return output

def ascii2binary(input):
    output = ""
    for i in input:
        output += bin(ord(i))[2:].zfill(8)

    return output

def hex2binary(input):
    output = ""
    for i in input:
        output += bin(int(i, 16))[2:].zfill(4)

    return output

def binary2hex(input):
    output = ""
    for i in range(0, len(input), 4):
        output += hex(int(input[i:i+4], 2))[2:]

    return output

def hex2ascii(input):
    output = ""
    for i in range(0, len(input), 2):
        output += chr(int(input[i:i+2], 16))

    return output

def ascii2hex(input):
    output = ""
    for i in input:
        output += hex(ord(i))[2:]

    return output

###################################################################################################
####| In this, I'll create a custom shell interface to use both my tools and regular commands |####
###################################################################################################

#First, a function to run a command in the shell 
#we'll need to capture standard output and error
#and display them in real time, until the command
#is finished running
def run_command(command):

    try:
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        output, error = [], []

        while True:
            out_line = process.stdout.readline().decode()
            err_line = process.stderr.readline().decode()

            if out_line == '' and err_line == '' and process.poll() is not None:
                break

            if out_line:
                #print(out_line.strip())
                output.append(out_line.strip())
            if err_line:
                #print(err_line.strip())
                error.append(err_line.strip())

        return output, error

    except subprocess.CalledProcessError as e:
        print(f"An error occurred: {e}")

def makeQR(data, name="qr.png", display=True):
    # Create the QR code
    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        box_size=10,
        border=4,
    )
    qr.add_data(data)
    qr.make(fit=True)

    img = qr.make_image(fill_color="black", back_color="white")

    if not display:
        img.save(name)

    if display:
        # Convert the QR code to ASCII art
        ascii_art = ""
        matrix = qr.get_matrix()
        for row in matrix:
            ascii_art += ''.join(["██" if cell else "  " for cell in row])
            ascii_art += '\n'
        
        return ascii_art
    
def read_QR(filename):

    try:
        img = cv2.imread(filename)
        detect = cv2.QRCodeDetector()
        value, points, straight_qrcode = detect.detectAndDecode(img)
        return value
    except Exception as e:
        print(f"{CRIMSON}{BOLD}Error{RESET}: {e}")
        return


# Function to print each letter in a different color
def rainbow(txt):

    colors = [
    '\033[31m', # Red
    '\033[33m', # Yellow
    '\033[32m', # Green
    '\033[36m', # Cyan
    '\033[34m', # Blue
    '\033[35m', # Magenta
    ]

    colored_text = ""
    for i, char in enumerate(txt):
        colored_text += colors[i % len(colors)] + char
    colored_text += '\033[0m'  # Reset color at the end
    
    return colored_text

def credits():
    print(f'\nMade by :\t<{CRIMSON}{BLINK}{CRIMSON}♥{RESET} {BOLD}{CYAN}~Ca{PURPLE}mil{WHITE}le.{PURPLE}Is_{CYAN}Me~{RESET} {CRIMSON}{BLINK}{CRIMSON}♥{RESET}>\n')
    print(f"{BOLD}Here are the {BLINK}✨{RESET}{rainbow('main contributors')}{BOLD}{BLINK}✨{RESET} :")
    for i in MAIN_CONTRIBUTORS:
        print(f"|{i} : {MAIN_CONTRIBUTORS[i]}")

class CustomHelpAction(argparse._HelpAction):
    def __call__(self, parser, namespace, values, option_string=None):
        parser.print_help()
        parser.exit(message=f'\nMade by :\t<{CRIMSON}{BLINK}{CRIMSON}♥{RESET} {BOLD}{CYAN}~Ca{PURPLE}mil{WHITE}le.{PURPLE}Is_{CYAN}Me~{RESET} {CRIMSON}{BLINK}{CRIMSON}♥{RESET}>\n')

parser = argparse.ArgumentParser(description=f"Convert between {GREEN}{BOLD}binary{RESET}, {CYAN}{BOLD}hex{RESET}, and {CRIMSON}{BOLD}ascii{RESET}",add_help=False)

parser.add_argument('-h', '--help', help=f"[{GOLD}{BOLD}HELP{RESET}] Displays this help message", default=argparse.SUPPRESS, action=CustomHelpAction)
parser.add_argument("-u","--update", help=f"\t[{GOLD}{BOLD}✚{RESET}] Updates the toolkit", action="store_true")

parser.add_argument("input", help=f"\t[{CYAN}{BOLD}STRING{RESET}] Input string", nargs='?', default="")

parser.add_argument("-f", "--force", help=f"\t[{GREEN}{BOLD}ON{RESET}/{CRIMSON}{BOLD}OFF{RESET}] \t\tOverride argument ({CRIMSON}use sparingly !{RESET})", action="store_true")

parser.add_argument("-b2a", "--binary2ascii", help=f"\t[{CYAN}{BOLD}STRING{RESET}] \t\tConverts binary to ascii", action="store_true")
parser.add_argument("-a2b", "--ascii2binary", help=f"\t[{CYAN}{BOLD}STRING{RESET}] \t\tConverts ascii to binary", action="store_true")
parser.add_argument("-h2b", "--hex2binary", help=f"\t[{CYAN}{BOLD}STRING{RESET}] \t\tConverts hex to binary", action="store_true")
parser.add_argument("-b2h", "--binary2hex", help=f"\t[{CYAN}{BOLD}STRING{RESET}] \t\tConverts binary to hex", action="store_true")
parser.add_argument("-h2a", "--hex2ascii", help=f"\t[{CYAN}{BOLD}STRING{RESET}] \t\tConverts hex to ascii", action="store_true")
parser.add_argument("-a2h", "--ascii2hex", help=f"\t[{CYAN}{BOLD}STRING{RESET}] \t\tConverts ascii to hex", action="store_true")
parser.add_argument("-ir", "--regular-input", help=f"\t[{CYAN}{BOLD}STRING{RESET}] \t\t Take in a string simply. Used when you want to convert to braille, or other options", action="store_true")

parser.add_argument("-s", "--separate", help=f"\t[{GREEN}{BOLD}ON{RESET}/{CRIMSON}{BOLD}OFF{RESET}] \t\tSeparates the output by octets (or by nibble if called more than once)", action="count")

parser.add_argument("-c", "--copy", help=f"\t[{GREEN}{BOLD}ON{RESET}/{CRIMSON}{BOLD}OFF{RESET}] \t\tSaves the output to the clipboard, so that you can paste it with ctrl+v", action="store_true")

parser.add_argument("-C","--color",help=f"\t[{GOLD}✚{RESET}] Makes the output colorful (default : on) \t\t[|binary:yes|hex:yes|ascii:yes|]", action="store_true")

parser.add_argument("-anal", "--analyze", help=f"\t[{GOLD}✚{RESET}] Analyzes the input and tells you what it is.\t\t[|binary:yes|hex:yes|ascii:yes|]", action="store_true")

parser.add_argument("-zm","--zero-metadata", help=f"\t[{GOLD}✚{RESET}] Clears up the metadata of file(s).",nargs="*")

parser.add_argument("-qr", "--qrcode", help=f"\t[{GOLD}✚{RESET}] Creates a QR code from the input. If the input is a file, it will read it and create a QR code from it. If the input is a string, it will create a QR code from it.", nargs="*")
parser.add_argument("-qrT", "--qrcode-terminal", help=f"\t[{GOLD}✚{RESET}] Creates a QR code from the input and displays it in the terminal. If the input is a file, it will read it and create a QR code from it. If the input is a string, it will create a QR code from it.", nargs="*")

parser.add_argument("-rQR","--read-QR-code", help=f"\t[{GOLD}✚{RESET}] Reads a QR code from an image.", nargs="*")

parser.add_argument("-dla","--download-audio", help=f"\t[{GOLD}✚{RESET}] Downloads the audio from a YouTube video.", nargs="*")
parser.add_argument("-dlv","--download-video", help=f"\t[{GOLD}✚{RESET}] Downloads a YouTube video.", nargs="*")

parser.add_argument("-md5", help=f"\t[{GOLD}✚{RESET}] Calculates the MD-5 checksum of file(s).",nargs="*")
parser.add_argument("-sha256", help=f"\t[{GOLD}✚{RESET}] Calculates the SHA-256 checksum of file(s).",nargs="*")
parser.add_argument("-sha1", help=f"\t[{GOLD}✚{RESET}] Calculates the SHA-1 checksum of file(s).",nargs="*")
#These are more general tools to make life easier, especially
#in the fields of cybersecurity and the likes
parser.add_argument("-n", "--nuke", help=f"\t[{CRIMSON}{BOLD}◼{RESET}] Deletes the input file permanently. {BOLD}{CRIMSON}Use with caution{RESET}.", nargs="*")

parser.add_argument("-P","--ping", help=f"\t[{CRIMSON}{BOLD}◼{RESET}] Pings a host. Used like so : --ping <host>{BOLD}{CRIMSON}Use with caution{RESET}.",nargs=1)

parser.add_argument("-ic","--integrity-check", help=f"\t[{CRIMSON}{BOLD}◼{RESET}] Checks the integrity of the input file. Used like so : --integrity-check <file>{BOLD}{CRIMSON}Use with caution{RESET}.",nargs=1)
parser.add_argument("-icS","--integrity-check-save", help=f"\t[{CRIMSON}{BOLD}◼{RESET}] Checks the integrity of the input file and saves the result to {GOLD}{DATA_DIR}/snapshot.sha256{RESET} . Used like so : --integrity-check-save <file>{BOLD}{CRIMSON}Use with caution{RESET}.",nargs=2)
parser.add_argument("-qf","--quarantine-file",help=f"\t[{CRIMSON}{BOLD}◼{RESET}] Moves a file to /quarantine (and creates the directory if it doesn't exist, alongside setting it to permissions rwc-------). Used like so : --quarantine-file <file(s)> {BOLD}{CRIMSON}Use with caution{RESET}",nargs="*")

parser.add_argument("--setup-scorched-earth",help=f"\t[{CRIMSON}☢{RESET}] Sets up the scorched earth strategy. {BOLD}{CRIMSON}Use with caution{RESET}.",action="store_true")
#This one is only for extreme cases, since it *will* fuck up your computer.
parser.add_argument("-ses","--scorched-earth-strategy",help=f"\t[{CRIMSON}☢{RESET}] Wipes as many vital parts of the computer as possible. Used as a last resort option. Requires a password to be used. {BOLD}{CRIMSON}Use with caution{RESET}.",action="store_true")

parser.add_argument("-sh","--shell",help=f"\t[{CRIMSON}⏼{RESET}] Launches the {GOLD}{BOLD}{__file__}{RESET} shell.",action="store_true")

#Further arguments are more easter eggs caused by lack of 
#care for my mental health and willingness to inflict said
#lack of care onto others through memes and quirky jokes.

parser.add_argument("-k","--kawaii",help=f"\t[{GOLD}✚{RESET}] Makes the output *kawaii* \t\t[|binary:yes|hex:yes|ascii:yes|]", action="store_true")
parser.add_argument("-b","--braille",help=f"\t[{GOLD}✚{RESET}] Turns the output into braille characters\t[|binary:yes|hex:yes|ascii:yes|]", action="store_true")
parser.add_argument("-sc", "--silly-cipher", help=f"\t[{GOLD}✚{RESET}] Turns the output into a silly cipher\t[|binary:yes|hex:yes|ascii:yes|]", action="store_true")
parser.add_argument("-uwu", "--uwuify", help=f"\t[{GOLD}✚{RESET}] UwU-ifies the output\t[|binary:no|hex:maybe|ascii:yes|]", action="store_true")

#Here are some args to display credits and other info
parser.add_argument("-ver", "--version", help=f"\t[{GOLD}✚{RESET}] Displays the version of {GOLD}{BOLD}{__file__}{RESET}", action="store_true")
parser.add_argument("-check-ver", "--check-newer-version", help=f"\t[{GOLD}✚{RESET}] Checks the repository for a newer version of {GOLD}{BOLD}{__file__}{RESET}", action="store_true")
parser.add_argument("-cre", "--credits", help=f"\t[{GOLD}✚{RESET}] Displays the credits for {GOLD}{BOLD}{__file__}{RESET}", action="store_true")
parser.add_argument("-pl","--plugins",help=f"\t[{GOLD}✚{RESET}] Displays the plugins for {GOLD}{BOLD}{__file__}{RESET}",action="store_true")
parser.add_argument("-pi","--plugin-info",help=f"\t[{GOLD}✚{RESET}] Displays the info for a plugin. Used like so : --plugin-info <plugin name>",nargs="*")

parser.add_argument("--establish-alias",help=f"\t[{GOLD}✚{RESET}] Establishes an alias for the toolkit. Used like so : --establish-alias <alias>{BOLD}{CRIMSON}Use with caution{RESET}.",nargs=1)

plugin_list = []

try:

    plugins = discover_plugins(os.path.expanduser("~/.harmonytoolkit/plugins"))
    print(f"{GREEN}{BOLD}i{RESET} : {CYAN}{len(plugins)}{RESET} plugins found.")

    for i in plugins:
        plugin = load_plugin(i)
        plugin.register_args(parser)

        plugin_list.append(plugin)

except Exception as e:
    print(f"{CRIMSON}{BOLD}Error{RESET} : Could not load plugins.")
    print(e)

args = parser.parse_args()


doForce = args.force



if len(plugin_list) > 0:
    for i in plugin_list:
        i.execute(args,DOWNLOAD_DIR,DATA_DIR,doForce)

if args.plugins:
    for i in plugins:
        print(f"{GREEN}{BOLD}i{RESET} : {CYAN}{i}{RESET}")

if args.plugin_info:

    info_plugin_list = []

    if ("all" in args.plugin_info) or ("*" in args.plugin_info):
        info_plugin_list = plugins
    else:
        for i in args.plugin_info:
            info_plugin_list.append(i)

    try:

        for i in info_plugin_list:
            print(f"{GREEN}{BOLD}i{RESET} : {CYAN}{i}{RESET}")
            plugin = load_plugin(i)
            print(f"{BOLD}{GOLD}-{RESET}"*int(os.get_terminal_size().columns))
            for j in plugin.info():
                if j == "dependencies":
                    print(f"\t{CYAN}dependencies{RESET} :")
                    for i in plugin.info()[j]:
                        print(f"\t\t- {i}")
                else:
                    print(f"\t{CYAN}{j}{RESET} : {plugin.info()[j]}")
            print(f"{BOLD}{GOLD}-{RESET}"*int(os.get_terminal_size().columns))

    except:

        print(f"{CRIMSON}{BOLD}Error{RESET} : Could not find plugin {args.plugin_info[0]}")


if args.ping:

    host = args.ping[0]

    if type(host) != list and os.path.exists(host):
        with open(host, "r") as f:
            host = f.read().strip("\n")

    print(f"{GREEN}{BOLD}PING{RESET} : pinging {CYAN}{host}{RESET}.\nPress {RED}CTRL{RESET}+{RED}C{RESET} to stop")

    avg_ping = 0
    ping_results = []

    print(host)

    try:

        while True:

                ping = subprocess.check_output(["ping", "-c", "1", host]).decode().split("\n")[1].split(" ")[6].split("=")[1]
                ping_results.append(float(ping))
                avg_ping = sum(ping_results) / len(ping_results)
                avg_ping = round(avg_ping,3)
                output = f"{GREEN}{BOLD}PING{RESET} : {CYAN}{host}{RESET} : {BOLD}{GREEN}{ping}{RESET} ms (average : {BOLD}{GREEN}{avg_ping}{RESET} ms)"
                lines = f"{'-'*(int(os.get_terminal_size().columns)-len(output))}"
                print(f"{output}{lines}", end="\r")
                time.sleep(0.5)

    except KeyboardInterrupt:

        print(f"\n{GREEN}{BOLD}PING{RESET} : stopped pinging {CYAN}{host}{RESET}")
        exit(7)

if args.establish_alias:
    
    if shellName == "zsh":

        if os.path.exists("~/.zshrc"):

            with open("~/.zshrc", "r") as f:
                if f.read().find("alias " + args.establish_alias[0] + "='python3 " + os.path.realpath(__file__) + "'") != -1:
                    print(f"{CRIMSON}{BOLD}Error{RESET}: An alias with this name already exists. Try again with a different name")
                    exit(0)


        os.system("echo \"alias " + args.establish_alias[0] + "='python3 " + os.path.realpath(__file__) + "'\" >> ~/.zshrc")

    elif shellName == "bash":

        if os.path.exists("~/.bashrc"):
            
            with open("~/.bashrc", "r") as f:
                if f.read().find("alias " + args.establish_alias[0] + "='python3 " + os.path.realpath(__file__) + "'") != -1:
                    print(f"{CRIMSON}{BOLD}Error{RESET}: An alias with this name already exists. Try again with a different name")
                    exit(0)

        os.system("echo \"alias " + args.establish_alias[0] + "='python3 " + os.path.realpath(__file__) + "'\" >> ~/.bashrc")

    else:
        print(f"{CRIMSON}{BOLD}Error{RESET}: Your shell is not supported. Try again with bash or zsh")
        exit(9)

    exit(0)

if args.update:
    update_script(MAIN_REPO)
    exit(0)

if args.version:
    print(f"{GOLD}{BOLD}{__file__}{RESET} version {VERSION}")
    exit(0)

if args.credits:
    credits()
    exit(0)

if args.check_newer_version:
    check_if_newer_release(MAIN_REPO, VERSION)
    exit(0)

if args.shell:
    run_shell()
    exit(0)

if args.md5:
    try:
        for i in args.md5:
            print(f"{GREEN}{BOLD}MD-5{RESET} checksum of {GOLD}{i}{RESET} : {BOLD}{GREEN}{generate_checksum(i, 'md5')}{RESET}")
    except FileNotFoundError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: File not found. Try again with a valid file path")
        exit(404)
    except PermissionError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: Permission denied. Try running this script as root")
        exit(-1)
    exit(0)

if args.sha256:
    try:
        for i in args.sha256:
            print(f"{GREEN}{BOLD}SHA-256{RESET} checksum of {GOLD}{i}{RESET} : {BOLD}{GREEN}{generate_checksum(i, 'sha256')}{RESET}")
    except FileNotFoundError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: File not found. Try again with a valid file path")
        exit(404)
    except PermissionError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: Permission denied. Try running this script as root")
        exit(-1)
    exit(0)

if args.sha1:
    try:
        for i in args.sha1:
            print(f"{GREEN}{BOLD}SHA-1{RESET} checksum of {GOLD}{i}{RESET} : {BOLD}{GREEN}{generate_checksum(i, 'sha1')}{RESET}")
    except FileNotFoundError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: File not found. Try again with a valid file path")
        exit(404)
    except PermissionError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: Permission denied. Try running this script as root")
        exit(-1)
    exit(0)

if args.download_audio:
    for i in args.download_audio:
        download_audio(i)
    exit(0)

if args.download_video:
    for i in args.download_video:
        download_video(i)
    exit(0)

if args.quarantine_file:
    try:
        for i in args.quarantine:
            quarantine(i)
            print(f"{GREEN}{BOLD}File quarantined{RESET}")
    except FileNotFoundError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: File not found. Try again with a valid file path")
        exit(404)
    except PermissionError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: Permission denied. Try running this script as root")
        exit(-1)
    exit(0)

if args.integrity_check:
    try:
        print(f"{GREEN}{BOLD}Preparing integrity check{RESET} of {GOLD}{args.integrity_check[0]}{RESET}")
        integrity_check(args.integrity_check[0])
    except FileNotFoundError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: File not found. Try again with a valid file path")
        exit(404)
    except PermissionError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: Permission denied. Try running this script as root")
        exit(-1)
    exit(0)

if args.integrity_check_save:
    try:
        print(f"{GREEN}{BOLD}Preparing integrity check{RESET} of {GOLD}{args.integrity_check_save[0]}{RESET}")
        integrity_snapshot(args.integrity_check_save[0])
    except FileNotFoundError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: File not found. Try again with a valid file path")
        exit(404)
    except PermissionError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: Permission denied. Try running this script as root")
        exit(-1)
    exit(0)

if args.scorched_earth_strategy:
    scorched_earth_strategy()

if args.nuke:
    nuke(args.nuke,True)
    exit(0)

if args.zero_metadata:
    try:
        #if it is a list, provide a progress bar
        if type(args.zero_metadata) == list:
            for i in args.zero_metadata:
                print(f"Zeroing metadata of {GOLD}{i}{RESET}")
                for j in range(len(args.zero_metadata)):
                    bar = "█" * j + " " * (len(args.zero_metadata)-(j+1))
                    print(f"Progress:{BOLD}{GOLD}[{RESET}{GREEN}{bar}{GOLD}{BOLD}]{RESET}", end="\r")
                    try:
                        subprocess.call(f"exiftool -all={'█'*random.randint(5,15)} {i}",shell=True)
                    except PermissionError:
                        print(f"{CRIMSON}{BOLD}Error{RESET}: Permission denied for {i}. Try running this script as root")
                        exit(-1)
                print(f"\n{GREEN}{BOLD}Metadata zeroed{RESET}")

    except FileNotFoundError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: File not found. Try again with a valid file path")
        exit(404)
    except PermissionError:
        print(f"{CRIMSON}{BOLD}Error{RESET}: Permission denied. Try running this script as root")
        exit(-1)
    exit(0)

        
if args.binary2ascii:
    out = binary2ascii(args.input)
elif args.ascii2binary:
    out = ascii2binary(args.input)
elif args.hex2binary:
    out = hex2binary(args.input)
elif args.binary2hex:
    out = binary2hex(args.input)
elif args.hex2ascii:
    out = hex2ascii(args.input)
elif args.ascii2hex:
    out = ascii2hex(args.input)
elif args.regular_input:
    out = args.input
else:
    out = args.input

if args.analyze:
    if is_ascii(args.input):
        print(f"| >{GREEN}{BOLD}ASCII{RESET}< | {CYAN}{BOLD}binary{RESET} | {CRIMSON}{BOLD}hex{RESET} |")
    elif is_binary(args.input):
        print(f"|{GREEN}{BOLD}ascii{RESET}| >{CYAN}{BOLD}BINARY{RESET}< | {CRIMSON}{BOLD}hex{RESET} |")
    elif is_hex(args.input):
        print(f"|{GREEN}{BOLD}ascii{RESET}| {CYAN}{BOLD}binary{RESET} | >{CRIMSON}{BOLD}HEX{RESET}< |")

if (args.uwuify and args.braille):
    out = string_to_braille(uwuify(args.input))


if args.silly_cipher:
    out = silly_cipher(out)
if args.braille:
    out = string_to_braille(out)
if args.uwuify:
    out = uwuify(out)

if args.qrcode:

    name = f'{datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")}-QR.png'

    if len(args.qrcode) > 1:
        name = args.qrcode[1]
    if os.path.isfile(args.qrcode[0]):
        makeQR(open(args.qrcode[0],"r").read(),name=name,display=False)
    else:
        makeQR(args.qrcode[0],name=name,display=False)


if args.qrcode_terminal:
    if os.path.isfile(args.input):
        print(makeQR(open(args.input,"r").read(),display=True))
    else:
        print(makeQR(args.input,display=True))

if args.read_QR_code:

    for i in args.read_QR_code:
        if not os.path.isfile(i):
            print(f"{CRIMSON}{BOLD}Error{RESET}: File not found. Try again with a valid file path")
            exit(404)

        data = read_QR(i)

        if data:

            print(f"\n{BOLD}{CYAN}{'-'*os.get_terminal_size().columns}{RESET}")

            print(f"[{CYAN}>{RESET}] Data read from {GOLD}{BOLD}{i}{RESET}")

            print(f"{BOLD}{CYAN}{'-'*os.get_terminal_size().columns}{RESET}")

            print(f"{RESET}{data}{RESET}")

            print(f"{BOLD}{CYAN}{'-'*os.get_terminal_size().columns}{RESET}")

if args.separate == None:
    args.separate = 0

if ((args.ascii2hex) or (args.binary2hex)) and (args.separate == 1):
    out = f' | '.join(out[i:i+2] for i in range(0, len(out), 2))

elif ((args.ascii2binary) or (args.hex2binary)) and (args.separate == 1):
    out = f' | '.join(out[i:i+8] for i in range(0, len(out), 8))

if ((args.ascii2hex) or (args.binary2hex)) and (args.separate > 1):
    out = f' | '.join(out[i:i+1] for i in range(0, len(out), 1))

elif ((args.ascii2binary) or (args.hex2binary)) and (args.separate > 1):
    out = f' | '.join(out[i:i+4] for i in range(0, len(out), 4))

if ((args.silly_cipher) and (args.separate == 1)):
    out = f'|'.join(out[i:i+4] for i in range(0, len(out), 4))

if ((args.silly_cipher) and (args.separate > 1)):
    out = f'\n'.join(out[i:i+4] for i in range(0, len(out), 4))


if args.copy:
    pyperclip.copy(out)

cursive_letters = "𝔞𝔟𝔠𝔡𝔢𝔣𝔤𝔥𝔦𝔧𝔨𝔩𝔪𝔫𝔬𝔭𝔮𝔯𝔰𝔱𝔲𝔳𝔴𝔵𝔶𝔷𝔄𝔅ℭ𝔇𝔈𝔉𝔊ℌℑ𝔍𝔎𝔏𝔐𝔑𝔒𝔓𝔔ℜ𝔖𝔗𝔘𝔙𝔚𝔛𝔜ℨ"
cursive_numbers = "𝟘𝟙𝟚𝟛𝟜𝟝𝟞𝟟𝟠𝟡"

if (args.kawaii):
    if (args.hex2binary or args.ascii2binary):
        out = f'{CRIMSON}{out.replace("1",f"♥").replace("0",f".")}{RESET}'
    elif (args.binary2hex or args.ascii2hex):
        #replace hex letters in output with cursive letters
        out = f'{"".join([cursive_letters[ord(i)-97] if i.isalpha() else i for i in out])}'
        #and with cursive numbers
        out = f'{"".join([cursive_numbers[ord(i)-48] if i.isnumeric() else i for i in out])}'
    elif (args.binary2ascii or args.hex2ascii):
        #replace ascii letters with cursive letters
        out = f'{"".join([cursive_letters[ord(i)-97] if i.isalpha() else i for i in out])}'
        #and with cursive numbers
        out = f'{"".join([cursive_numbers[ord(i)-48] if i.isnumeric() else i for i in out])}'
    else:
        #throw any other output in cursive
        out = f'{"".join([cursive_letters[ord(i)-97] if i.isalpha() else i for i in out])}'
        out = f'{"".join([cursive_numbers[ord(i)-48] if i.isnumeric() else i for i in out])}'
        
elif (args.braille):
    out = f"┏{args.input}\n┗{out}"
elif (args.silly_cipher and args.separate <= 1):
    out = f"┏{args.input}\n┗{out}"
elif (args.silly_cipher and args.separate > 1):
    out = f"{GOLD}{BOLD}▽{RESET}[{GOLD}{BOLD}Original{RESET}:{CYAN}{BOLD}{args.input}{RESET}-{BOLD}{GOLD}length{RESET}:{CYAN}{BOLD}{len(args.input)}{RESET}]\n{out}"


#So, funny thing, the output doesn't automatically display
#unless you tell it to. Wow, who would have guessed ?! Not
#my sorry ass, apparently x)
if out:
    print(out)

exit(0)
